#+title: My Emacs configuration
#+author: Justin Smith
#+toc: true
#+startup: indent
#+property: header-args :mkdirp yes :comments no :tangle init.el :results output silent

#+begin_src emacs-lisp :exports none
  ;; This file is automatically generated; please do not modify it!
  ;; Please modify config.org instead and untangle it!
#+end_src

* Introduction

This is my [[https://www.gnu.org/software/emacs/][GNU Emacs]] configuration.

This configuration is oriented around the following:

 - Vim-style keybindings via evil
 - One menu to access most features, like spacemacs
 - An attempt to look OK-ish
 - A focus on =org-mode=, "curly-brace" languages (C/C++, Go, PHP,
   some JavaScript), and webdev

I am not using spacemacs (which offers all of the above) because I
found myself turning on features and then later wondering why my emacs
was running so slow.  That's not so much spacemacs' fault, but since
it's not my code, it gets tricky to suss out where the problem lies.
I am not claiming my code is better than spacemacs; actually it's
probably the reverse.

This configuration is opinionated; it assumes you are heavily sold
on vim keybindings and moreover that you... ahem... agree with me,
I suppose.  In particular, while I like all the packages here, I
may indulge in some... rants... about functionality I find... odd.

(After all, this is a realm of thought where the very choice of
typographical whitespace is fraught with [[https://www.youtube.com/watch?v=SsoOG6ZeyUI][religious significance]]; text
editors are going to be naturally pretty scary in that regard ^_^)

* Basic setup

Basically, all the rough edges that can be changed from within vanilla
Emacs are sanded, and my preferred way of installing and loading
libraries is set up.  The rest of the guide leans heavily on
=use-package= so it gets a section here as well.

** Early init

You can speed up Emacs' init a bit by certain configurations in
=early-init.el=, which runs earlier in the Emacs bootup process,
before =init.el= runs.

I stole much of this from [[https://github.com/hlissner/doom-emacs/blob/develop/early-init.el][Doom Emacs]], but the org-babel style of
loading from [[https://etienne.depar.is/emacs.d/init.html][this config]] ([[https://git.umaneti.net/emacs.d/tree/init.org][org]]).

#+begin_src emacs-lisp :tangle early-init.el
;; This file is automatically generated; please do not modify it!
;; Please modify config.org instead and untangle it!

;; Defer garbage collection for now -- re-enabled after Emacs init
(setq gc-cons-threshold most-positive-fixnum)

;; Fixes to hopefully get Emacs to do some things (lsp-mode) faster
(setq read-process-output-max (* 1024 1024))

;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
(if (functionp 'tool-bar-mode) (tool-bar-mode -1))
(if (functionp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
(if (functionp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (functionp 'menu-bar-mode) (menu-bar-mode -1))

;; Disable package.el
(setq package-enable-at-startup nil)

;; Resizing the Emacs frame can be a terribly expensive part of changing the
;; font. By inhibiting this, we easily halve startup times with fonts that are
;; larger than the system default.
(setq frame-inhibit-implied-resize t)

;; Ignore X resources
(advice-add #'x-apply-session-resources :override #'ignore)

;; Prevent unwanted runtime builds in gccemacs (native-comp)
(setq comp-deferred-compilation nil)

;; Disable startup screen
(setq inhibit-startup-screen t)

;; Darkula bg/fg colors
(when (display-graphic-p)
  (set-face-background 'default "#282a36" nil)
  (set-face-foreground 'default "#f8f8f2" nil))
#+end_src

** Variables

Let's start by defining a bunch of variables needed by this
configuration.  I use a number of custom directories, we define these
here.

#+begin_src emacs-lisp
(defvar jws/emacs-backup-dir
  (expand-file-name (concat user-emacs-directory ".cache/backups"))
  "Where to put Emacs backup files")
(defvar jws/emacs-desktop-dir
  (expand-file-name (concat user-emacs-directory ".cache/desktop"))
  "Where to put Emacs .desktop files")
(defvar jws/emacs-library-dir
  (expand-file-name (concat user-emacs-directory "lisp"))
  "Contains all unpackaged libraries required by this configuration")
(defvar jws/emacs-site-library-dir
  (expand-file-name (concat user-emacs-directory "site-lisp"))
  "Contains unpackaged libraries specific to this machine")
#+end_src

And here are a number of important file paths.

#+begin_src emacs-lisp
(defvar jws/config-file
  (expand-file-name (concat user-emacs-directory "config.org"))
  "This file")
(defvar jws/site-file
  (expand-file-name (concat user-emacs-directory "site-init.el"))
  "The site-specific configuration")
(defvar jws/custom-file
  (expand-file-name (concat user-emacs-directory "custom.el"))
  "Where Emacs Customize writes data")
#+end_src

And finally, variables that may be changed elsewhere in the config.

#+begin_src emacs-lisp
(defvar jws/default-x-pos 0
  "Default x-coordinate (px from top-left corner) to place GUI frame")
(defvar jws/default-y-pos 0
  "Default y-coordinate (px from top-left corner) to place GUI frame")

(defvar jws/default-width-columns 100
  "Default GUI frame width, in columns of characters")
(defvar jws/default-height-rows 35
  "Default GUI frame height, in rows of characters")

(defvar jws/default-font "monospace-10.5"
  "Default GUI frame font")
#+end_src

** Customize =Customize=

Emacs has an automatic customization system, called =Customize=, which
will barf inscrutable s-expressions (with ugly comments telling you
not to modify the output) through our beautiful =init.el= unless you
redirect its output.  We will load this file's values later.

#+begin_src emacs-lisp
(setq custom-file jws/custom-file)
#+end_src

** Set up straight.el

This must be done before we do anything else -- bootstrapping
=straight.el=:

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Automatically install packages listed in =use-package= invocations:

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
#+end_src

** Set up use-package

[[https://github.com/jwiegley/use-package][use-package]] is an invaluable library that allows one to isolate
different libraries being loaded in one's =.emacs= blob and load them
efficiently.  The rest of the config relies heavily upon =use-package=,
so it is loaded very early as well.

#+begin_src emacs-lisp
(straight-use-package 'use-package)

;; prevents use-package from automagically appending "-hook" to the name
;; of hooks bound by the :hook keyword
(setq use-package-hook-name-suffix nil)
#+end_src

** Load unpackaged libraries

Libraries included with this config, but not in MELPA, are under
=lisp/=:

#+begin_src emacs-lisp
(if (file-exists-p jws/emacs-library-dir)
    (let ((default-directory jws/emacs-library-dir))
      (add-to-list 'load-path default-directory)
      (normal-top-level-add-subdirs-to-load-path)))
#+end_src

** Backups

I really dislike how Emacs handles backups and do some pretty
substantial changes to same.

First off, let's create the backup directory:

#+begin_src emacs-lisp
(if (not (file-exists-p jws/emacs-backup-dir))
    (make-directory jws/emacs-backup-dir t))
#+end_src

And have Emacs use it:

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,jws/emacs-backup-dir)))
#+end_src

And finally change a bunch more settings:

#+begin_src emacs-lisp
;; Backup by copying files
(setq backup-by-copying t)

;; Prune old backups
(setq delete-old-versions t)

;; Control how many old backups are kept
(setq kept-old-versions 6)
(setq kept-new-versions 2)

;; Always number the backups
(setq version-control t)

;; Make backup files, even if the file's in version control
(setq vc-make-backup-files t)
#+end_src

Disable auto-save; otherwise IIRC Emacs prompts you annoyingly
to save them at some inconvenient point.  I generally remember
to save my files on my own and do not need this.

#+begin_src emacs-lisp
(setq auto-save-default nil)
#+end_src

** Clean up old buffers

#+begin_src emacs-lisp
(use-package midnight
  :straight nil
  :demand t
  :init (midnight-mode t)
  :custom
  (midnight-delay-set "5:30am")
  (clean-buffer-list-kill-buffer-names
   '("*Flymake log*" "*compilation*" "*elfeed-log*" "*elfeed-search*" "*lsp-log*" "*straight-process*")))
#+end_src

** Usability

Here are some settings to make Emacs more usable in general.

A warning:  I am disabling a number of "safety measures" that Emacs
enables.  Some are silly and the equivalent of [[https://en.wikipedia.org/wiki/Office_Assistant][Clippy]] getting in your
way in Office 2000.  Some are pretty sensible; I will note those.
Most of the other changes here are from [[https://github.com/technomancy/better-defaults][better-defaults]].

Use the X clipboard rather than whatever skanky "selection" Emacs
uses.

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

Sometimes Emacs wants a =y= or =n= for yes/no questions, sometimes it
requires a =yes= or =no=.  Make everything =y= / =n=.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Enable some disabled functions that confuse some new (l)users:

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil) ;; C-x n n
(put 'narrow-to-defun 'disabled nil) ;; C-x n d
(put 'dired-find-alternate-file 'disabled nil)
#+end_src

Set all theme files as "safe" and thus do not prompt when loading
them.  This is a legit concern.  I only install the =doom-themes=
and I trust them, but still there's nothing stopping the owner from,
say, selling to a malevolent person who sneaks elisp to mine BTC
into the themes.

#+begin_src emacs-lisp
(setq custom-safe-themes t)
#+end_src

Always put point in help windows (info, describe-variable...) so
that one does not have to hunt the buffer down to close it.

#+begin_src emacs-lisp
(setq help-window-select t)
#+end_src

Do not load elisp bytecode if the associated elisp source is newer.

#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

And here I define a setting that confuses *me*; =C-x C-z= minimizes
the window by default, which I cannot stand because it's next to a
whole plethora of =C-x= commands.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-x C-z"))
#+end_src

Add the currently visited buffer in the window title, to make it
easier to search for Emacs frames.

#+begin_src emacs-lisp
(setq frame-title-format `(,(user-login-name) "@" ,(system-name) " - %b"))
#+end_src

Change the scratch buffer to load =org-mode= instead of elisp (to
make it easier to put whatever text there; also change its text.

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message "\
Please type =SPC= to use global commands, or =,= to use per-mode
commands.

This screen also acts as a scratch =org-mode= buffer for text you do
not want to save.  Lisp evaluation can be done via [[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel]].

")
#+end_src

** Hydra (menus)

The [[https://github.com/abo-abo/hydra][hydra]] package allows for easy-ish interactive menus.

#+begin_src emacs-lisp
(use-package hydra
  :commands (defhydra))
#+end_src

Note that =hydra= uses a "color" system where keybinds are assigned
a color, which determines their behavior.  For our purposes:

 - red (the default) runs the command and jumps right back into the
   hydra
 - blue runs the command and exits the hydra

I use blue very extensively since most commands are going to be
fire-and-forget.

It's sometimes handy to make a hydra that can "change colors," so that
you have one menu that only works for one operation, and one that
works for multiple operations.  My lisp-fu is terrible and so I stole
the following macro to do exactly this from [[https://github.com/abo-abo/hydra/issues/230][here]]:

#+begin_src emacs-lisp
(defmacro jws/defmultihydra (names-body &optional docstring &rest heads)
  "Taken from https://github.com/abo-abo/hydra/issues/230"
  (cons 'progn
        (mapcar (lambda (nb)
                  `(defhydra ,(car nb) ,(cdr nb) ,docstring ,@heads))
                names-body)))
#+end_src

* Appearance/visuals

I like a very minimal Emacs (and Vim) window since both were
made to be driven from the keyboard.

I have this labeled "Vim-style line-by-line scrolling" and
I wish I knew exactly what it did.  I do recall not liking how
Emacs scrolled out-of-the-box.

#+begin_src emacs-lisp
(setq scroll-step 1)
(setq scroll-conservatively 10000)
#+end_src

Turn the "system bell" off.  The last time this was relevant to
computers, I was not alive yet and bell bottoms were en vogue; in 2019
it shows as an annoying full-screen flash on most computers.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

** Icons

[[https://github.com/domtronn/all-the-icons.el][all-the-icons]] pulls in several icon fonts which can be used by other
packages (e.g. =doom-modeline=).

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

Installation of the fonts must be done (once per machine) via the
command

#+begin_src emacs-lisp :tangle no
(all-the-icons-install-fonts)
#+end_src

** Themes

Install doom-themes, which are a nice set of themes that work with a
lot of libraries and look nice:

#+begin_src emacs-lisp
(use-package doom-themes)
#+end_src

** Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is an attractive, featureful, and performant modeline
replacement.

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init-hook . doom-modeline-mode)
  :config
  (column-number-mode)
  (setq doom-modeline-buffer-file-name-style 'buffer-name
        doom-modeline-icon t
        doom-modeline-major-mode-icon t
        doom-modeline-buffer-state-icon t))
#+end_src

[[https://github.com/tarsius/minions][minions]] hides all those pesky minor-modes behind a clickable menu.
Unlike the more popular [[https://github.com/myrjola/diminish.el][diminish]], =minions= just hides everything,
which is fine by me.

#+begin_src emacs-lisp
(use-package minions
  :config
  (minions-mode 1))
#+end_src

Sometimes you just gotta have fun, nyan~ ^_^

(In all seriousness, =nyan-mode= is a nice document position
indicator.)

#+begin_src emacs-lisp
(use-package nyan-mode
  :config
  (nyan-mode)
  (setq nyan-bar-length 20))
#+end_src

** Fonts

I've set a default font I can expect to be on most machines (DejaVu
Sans Mono) way above; now let's get "sane defaults" on other OSes.  I
don't use macOS so I just grabbed the most recent default, figuring
Mac folks generally upgrade.

#+begin_src emacs-lisp
(if (or (equal system-type 'windows-nt)
        (equal system-type 'ms-dos)
        (equal system-type 'cygwin))
    (setq jws/default-font "Consolas-11"))

(if (equal system-type 'darwin)
    (setq jws/default-font "San Francisco Mono-11"))
#+end_src

Emacs functions to query fonts have the unfortunate and frustrating
requirement that they be run from a GUI frame.  So while I'd like to
check for the presence of Fira Sans, Pragmata, etc... I can't in a
cross-platform way.

I define a friendlier function to get said font data that returns
the stuff I care about in a cons cell.  Again, it requires a GUI
emacs frame to function.

#+begin_src emacs-lisp
(defun jws/get-current-frame-font-specs ()
    "Calculates the size of a character cell.

The data is returned in a cons cell, (height width).
This function must be run from a GUI frame only."
  (let* ((font-vector (query-font (face-attribute 'default :font)))
         (ascent (elt font-vector 4))
         (descent (elt font-vector 5))
         (average-width (elt font-vector 7)))
    (cons (+ ascent descent) average-width)))
#+end_src

** Frame settings

I don't really like the =default-frame-alist= that is used to set
GUI frame settings e.g. font, size, position.  So I've defined my
own functions.

#+begin_src emacs-lisp
(defun jws/use-default-frame-alist ()
  "Sets emacs frame to the default frame size."
  (interactive)
  (set-frame-font (cdr (assq 'font default-frame-alist)))
  (set-frame-position (selected-frame)
                      (cdr (assq 'top default-frame-alist))
                      (cdr (assq 'left default-frame-alist)))
  (set-frame-size (selected-frame)
                  (cdr (assq 'width default-frame-alist))
                  (cdr (assq 'height default-frame-alist))))

(defun jws/set-my-default-frame-alist ()
  "Sets default emacs frame size to *my* personal specifications."
  (delete (assq 'font default-frame-alist) default-frame-alist)
  (add-to-list 'default-frame-alist `(font . ,jws/default-font))
  (delete (assq 'left default-frame-alist) default-frame-alist)
  (add-to-list 'default-frame-alist `(left . ,jws/default-x-pos))
  (delete (assq 'top default-frame-alist) default-frame-alist)
  (add-to-list 'default-frame-alist `(top . ,jws/default-y-pos))
  (delete (assq 'width default-frame-alist) default-frame-alist)
  (add-to-list 'default-frame-alist `(width . ,jws/default-width-columns))
  (delete (assq 'height default-frame-alist) default-frame-alist)
  (add-to-list 'default-frame-alist `(height . ,jws/default-height-rows)))
#+end_src

Set the =default-frame-alist= with the defaults we set early on.

#+begin_src emacs-lisp
(jws/set-my-default-frame-alist)
#+end_src

I include a function to help calculate row/column sizes given the
percent of the screen you want to use.  Since it uses my font
function, it requires a GUI emacs frame as mentioned earlier.

#+begin_src emacs-lisp
(defun jws/calculate-frame-size (percent-wide percent-high)
  "Calculates size for Emacs frame.

This is an interactive command, and should be run from a GUI frame
only, as font-querying commands cannot be run from terminal emacs
frames.  (What an irritating limitation!)

PERCENT-WIDE and PERCENT-HIGH must be floating-point numbers between 0
and 1."
  (interactive "nPercent width (0 to 1): \nnPercent height (0 to 1): ")
  (if window-system
      (let* ((rows-fudge-factor 3) ; we need to take about three rows off (for menubar, modeline, and minibuf)
             (font-height (car (jws/get-current-frame-font-specs))) ; get height of current font
             (font-width (cdr (jws/get-current-frame-font-specs))) ; get width
             (screen-rows-high (- (/ (display-pixel-height) font-height)
                                  rows-fudge-factor)) ; calculate the # of rows on screen given current font
             (screen-cols-wide (/ (display-pixel-width) font-width)) ; ditto for columns
             (frame-rows-high (floor (* percent-high screen-rows-high))) ; calculate rows for this fram
             (frame-cols-wide (floor (* percent-wide screen-cols-wide)))) ; ditto, for columns

        (message "Set your frame to %d columns wide and %d rows high."
                 frame-cols-wide frame-rows-high))
    (message "This command should be run from a GUI frame, sorry...")))
#+end_src

Define a simple function to create a maximized frame.

#+begin_src emacs-lisp
(defun jws/make-maximized-frame ()
  (interactive)
  (make-frame '((fullscreen . maximized))))
#+end_src

For some reason there are functions to change the text scale, but
none to actually reset it!

#+begin_src emacs-lisp
(defun jws/text-scale-reset ()
  "Reset text scale."
  (interactive)
  (text-scale-set 0))
#+end_src

A few more functions to handle the Emacs frame's transparency.

#+begin_src emacs-lisp
(defun jws/get-frame-transparency ()
  "Get transparency of current frame."
  (let ((trans (frame-parameter (selected-frame) 'alpha)))
    (if (eq trans nil) 100 trans)))

(defun jws/clamp (lo hi val)
  "Bound/clamp value VAL between LO and HI."
  (if (< val lo) lo
    (if (> val hi) hi
      val)))

(defun jws/set-frame-transparency (transparency)
  "Set transparency of current frame to TRANSPARENCY.

Note that TRANSPARENCY cannot go below 10; this is to prevent
the user from creating totally transparent windows and then
forgetting where they might be."
  (set-frame-parameter (selected-frame)
                       'alpha
                       (jws/clamp 10 100 transparency)))

(defun jws/increase-transparency ()
  "Make frame more transparent/less opaque."
  (interactive)
  (jws/set-frame-transparency (- (jws/get-frame-transparency) 1)))

(defun jws/decrease-transparency ()
  "Make frame less transparent/more opaque."
  (interactive)
  (jws/set-frame-transparency (+ (jws/get-frame-transparency) 1)))

(defun jws/reset-transparency ()
  "Make frame completely opaque."
  (interactive)
  (jws/set-frame-transparency 100))
#+end_src

* Functionality
** Environment variables

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (or (eq window-system nil) (memq window-system '(x ns mac)))
  :init
  (exec-path-from-shell-initialize))
#+end_src

** Keybindings

This is the first thing that gets complicated, because I'm all in
on Vim-style modal editing.

*** =evil=: Vim compatibility

Vim compatibility is the raison d'être of the whole guide.  This is
done with the [[https://github.com/emacs-evil/evil][evil]] package.

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-keybinding nil
        evil-undo-system 'undo-fu)
  :config
  (evil-mode t))
#+end_src

=evil-surround= is a port of [[https://github.com/tpope/vim-surround][surround.vim]].

#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

=evil-collection= tries to bring vi/evil keybindings to other Emacs
modes.

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src

*** =general=: Leader keys

First off, let's unilaterally clear off =C-SPC= and =C-,=:

#+begin_src emacs-lisp
(global-unset-key (kbd "C-SPC"))
(global-unset-key (kbd "C-,"))
#+end_src

[[https://github.com/noctuid/general.el][general]] allows one to define "leader" keymaps easily.  I had been
using =hydra= for this but it's more optimized for interactive menus
(which I do use in this configuration, defined elsewhere).

#+begin_src emacs-lisp
(use-package general
  :commands (general-create-definer))
#+end_src

And now we start binding keys.

#+begin_src emacs-lisp
(general-define-key :keymaps '(normal)
                    "+" 'er/expand-region
                    "g c" 'avy-goto-char
                    "g l" 'avy-goto-line)
#+end_src

=general= has the concept of a "definer," which more or less sets
up a "keymap" that can override other keymaps and change the key
that enters the keymap depending on the state.

I define two "leader keys" using definers.  The first is a "main menu"
that can be accessed via =SPC= in evil normal mode and =C-SPC= in all
others.  All functions here should either be built into Emacs or
autoloaded via =use-package=.

#+begin_src emacs-lisp
(general-create-definer jws/primary-leader
  :keymaps 'override
  :states '(insert emacs normal hybrid motion visual operator)
  :prefix "SPC"
  :non-normal-prefix "C-SPC")

(jws/primary-leader
  "" nil

  "<delete>" '(delete-frame :wk "KillFrame")
  "<tab>" '(jws/switch-to-previous-buffer :wk "PrevBuf")

  "b" '(:ignore t :wk "Buffers")
  "b SPC" '(jws/scratch-switch :wk "Switch to scratch")
  "b c" '(clone-indirect-buffer-other-window :wk "Clone buffer")
  "b i" '(ibuffer :wk "Buffer list")
  "b k" '(kill-this-buffer :wk "Kill buffer")
  "b s" '(save-buffer :wk "Save buffer")
  "b S" '(write-file :wk "Save buffer elsewhere")
  "b u" '(bury-buffer :wk "Bury buffer")

  "e" '(:ignore t :wk "Emacs")
  "e c" '(jws/open-emacs-config :wk "Config")
  "e s" '(jws/open-emacs-site-config :wk "SiteConfig")
  "e SPC" '(jws/scratch-switch :wk "Scratch")
  "e r" '(jws/reload-emacs-config :wk "Reload")
  "e t" '(jws/untangle-emacs-config :wk "Untangle")
  "e d" '(toggle-debug-on-error :wk "Debug")
  "e q" '(jws/server-shutdown :wk "KillServer")
  "e k" '(server-start :wk "StartServer")
  "e u" '(straight-pull-all :wk "Update")

  "f" '(:ignore t :wk "Files")
  "f a" '(ff-find-other-file :wk "Other")
  "f f" '(find-file :wk "Open")

  "h" '(:keymap help-map :wk "Help")
  "i" '(imenu :wk "Imenu")
  "k" '(kill-this-buffer :wk "KillBuf"))
#+end_src

The second leader is a secondary, "mode-specific" one accessed via =,=
in normal mode and =C-,= in all others.

#+begin_src emacs-lisp
(general-create-definer jws/secondary-leader
  :keymaps 'override
  :states '(insert emacs normal hybrid motion visual operator)
  :prefix ","
  :non-normal-prefix "C-,")
#+end_src

*** =which-key=: Describe what various keys do

[[https://github.com/justbur/emacs-which-key][which-key]] helps with all the crazy leader bindings -- if you stop on a
prefix key, it'll show you what your options are so you know how what
you've bound =M-x butterfly= to.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode)
  (setq which-key-idle-delay 0.2))
#+end_src

** Buffer splitting

=display-buffer-alist= is infamously gnarly.

I've tried [[https://github.com/nex3/perspective-el/tree/697d95f24e055eb9725781d179d7db63d6afd2b5#some-musings-on-emacs-window-layouts][this rather extreme setting in perspective.el's README]] ([[https://www.reddit.com/r/emacs/comments/llvyxe/hey_emacs_dont_move_my_windows_customizing/gntoxvm/][via
this Reddit thread]]) that force all new buffers to display, full-size,
in the current window.  It works, but for things like =*compilation*=
I found it annoying, and it seems to have straight-up broke =*Register
Preview*=.

[[https://protesilaos.com/dotemacs/#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Prot's .emacs has a easy-to-work-with display-buffer-alist]] that I used
as inspiration.  None of the existing functions did exactly what I
wanted, but =display-buffer-below-selected= came closest.  But for
some kinds of buffers (e.g. compilation) I wanted unconditional switching
to that buffer regardless of Emacs defaults, so I hacked it in.

#+begin_src emacs-lisp
;; The original inspiration for this was here:
;; https://emacs.stackexchange.com/questions/55210/using-display-frame-alist-to-force-switch-to-buffer
(defun jws/display-buffer-below-selected-and-switch (buffer alist)
  "Split selected buffer and display BUFFER in it, while switching to it."
  (select-window (display-buffer-below-selected buffer alist)))

(setq display-buffer-alist
      '(;; bottom side window
        ("\\*Messages.*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.16)
         (side . bottom))
        ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.16)
         (side . bottom))
        ("\\*compilation.*"
         (display-buffer-reuse-window jws/display-buffer-below-selected-and-switch)
         (window-height . 0.16)
         (side . bottom))
        ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.16)
         (side . bottom))
        ("\\*Help.*"
         (display-buffer-reuse-window jws/display-buffer-below-selected-and-switch)
         (window-height . 0.35)
         (side . bottom))
        ("\\*Faces\\*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.35)
         (side . bottom))
        ("\\*Custom.*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.35)
         (side . bottom))
        ("\\*\\vc-.*"
         (jws/display-buffer-below-selected-and-switch)
         (window-height . 0.35)
         (side . bottom))
        ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
         (display-buffer-reuse-window jws/display-buffer-below-selected-and-switch)
         (window-height . 0.35)
         (side . bottom))
        ("\\*\\(Output\\|Register Preview\\).*"
         (display-buffer-below-selected))))

(setq even-window-sizes nil ; display-buffer hint: avoid resizing
      switch-to-buffer-in-dedicated-window 'pop)
#+end_src

** Undo system

#+begin_src emacs-lisp
(use-package undo-fu
  :after evil
  :config
  (general-define-key :keymaps '(normal)
                      "u" 'undo-fu-only-undo
                      "C-r" 'undo-fu-only-redo))
#+end_src

** Incremental narrowing (=icomplete=, =consult=, and friends)

i.e. speeding up menu traversal.

(Used to call this "menu completion"; "incremental narrowing," from
Selectrum's =README=, is a much better/descriptive term)

I had used [[https://github.com/abo-abo/swiper][counsel and ivy]] for a long time, then moved briefly to
[[https://github.com/raxod502/selectrum][selectrum]] before trying plain ol' =icomplete= and finding it (with
some changes) very nice.

*** =icomplete=

Define some keys to move up/down the list, and make =TAB= complete
the first thing in the list.  Also make completion case-insensitive.

The only downside vs. =selectrum= and the like is that you must
complete fully before committing to a choice with =RET=, or else it'll
leave partial input.

#+begin_src emacs-lisp
(use-package icomplete
  :straight nil
  :demand t
  :general
  (:keymaps 'icomplete-minibuffer-map
            "SPC" 'self-insert-command
            "RET" 'icomplete-force-complete-and-exit
            "<tab>" 'icomplete-force-complete
            "<down>" 'icomplete-forward-completions
            "<up>" 'icomplete-backward-completions
            "C-j" 'icomplete-forward-completions
            "C-k" 'icomplete-backward-completions)
  :custom
  (read-file-name-completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  (completion-ignore-case t)
  (icomplete-max-delay-characters 0)
  (icomplete-compute-delay 0)
  :config
  (icomplete-mode +1))
#+end_src

=icomplete= displays horizontally by default; [[https://github.com/oantolin/icomplete-vertical][icomplete-vertical]]
causes it to display vertically instead.

#+begin_src emacs-lisp
(use-package icomplete-vertical
  :after icomplete
  :custom
  (icomplete-vertical-prospects-height 15)
  :config
  (icomplete-vertical-mode +1))
#+end_src

*** [[https://github.com/oantolin/orderless][orderless]]

=orderless= provides "fuzzy" searching to =icomplete=:

#+begin_src emacs-lisp
(use-package orderless
  :after icomplete
  :custom
  (completion-styles '(orderless)))
#+end_src

*** [[https://github.com/minad/consult][consult]]

=consult= is like =ivy='s =counsel=; it provides various nifty utility
functions powered by =completing-read= and thus usable by =icomplete=
and =selectrum=.

#+begin_src emacs-lisp
(use-package consult
  :ensure t
  :general
  (jws/primary-leader
    "bb" '(consult-buffer :wk "Switch")
    "fr" '(consult-recent-file :wk "Recent")
    "fb" '(consult-bookmark :wk "Bkmark")
    "r" '(consult-register-load :wk "LoadRegister")
    "R" '(consult-register-store :wk "SaveRegister")
    "/" '(consult-ripgrep :wk "Search"))
  :commands (consult-flymake
             consult-outline)
  :init
  (setq register-preview-delay 0.8
        register-preview-function #'consult-register-format
        xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :custom
  (consult-preview-key nil)
  (consult-project-root-function #'projectile-project-root)
  :config
  (autoload 'projectile-project-root "projectile"))
#+end_src

*** [[https://github.com/DarwinAwardWinner/amx][amx]]

=consult= does not provide an =M-x= that remembers your past commands,
so pull in =amx=:

#+begin_src emacs-lisp
(use-package amx
  :general
  (:keymaps 'override "M-x" 'amx)
  (:keymaps 'normal ";" 'amx)
  (jws/primary-leader
    "SPC" '(amx :wk "M-x")))
#+end_src

*** [[https://github.com/minad/marginalia/][marginalia]]

=marginalia= adds various helpful text to various =consult= commands:

#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :init
  ;; the documentation says it has to be NOT lazily loaded
  (marginalia-mode)
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light)))
#+end_src

** Contextual menu ([[https://github.com/oantolin/embark/][embark]])

=embark= enables one to perform additional actions on selected items
much like =ivy= & =counsel= have.  Additionally, it extends this
capability *outside of the minibuffer menus*, which means it becomes
more like a right-click contextual menu.

#+begin_src emacs-lisp
(defun jws/embark-action-which-key (map _target)
  (which-key--show-keymap "Embark" map nil nil 'no-paging)
  #'which-key--hide-popup-ignore-command)

(use-package embark
  :ensure t
  :general
  (:keymaps 'override "C-'" 'embark-act)
  :custom
  (embark-prompter 'embark-keymap-prompter)
  (embark-action-indicator 'jws/embark-action-which-key)
  (embark-become-indicator embark-action-indicator))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t
  :hook (embark-collect-mode-hook . embark-consult-preview-minor-mode))
#+end_src

** Text search

I had been using =swiper= for this (in the same repo as =ivy= and
=counsel=) but I've seen some glitchiness with it.

I'm keeping my eyes on [[https://github.com/raxod502/ctrlf][ctrlf]] but it doesn't interoperate with evil's
bindings yet.  [[https://github.com/emacsorphanage/anzu][anzu]] implements =ctrlf='s match counts while staying
mostly pretty simple.

#+begin_src emacs-lisp
(use-package anzu
  :bind (([remap query-replace] . 'anzu-query-replace)
   ([remap query-replace-regexp] . 'anzu-query-replace-regexp))
  :config
  (global-anzu-mode +1))
#+end_src

** Text completion

[[http://company-mode.github.io/][company-mode]] is currently the go-to for providing text completion in
Emacs.  I had previously gotten somewhat used to [[https://github.com/auto-complete/auto-complete][auto-complete]] and in
many ways preferred that package to =company= -- but it's not
seemingly maintained anymore.  So... we just hack the heck out of
=company=.

#+begin_src emacs-lisp
(use-package company
  :init
  (company-mode)
  (add-hook 'after-init-hook 'company-tng-mode)
  :config
  ;; These are where company gets its completion data from, and their
  ;; priority
  (setq company-backends
        '((company-files                ; files & directory
           company-keywords             ; keywords
           company-capf
           company-yasnippet)
          (company-abbrev company-dabbrev)))

  ;; These are how company displays said data
  ;; note that company-tng-mode adds frontends, as does company-quickhelp
  (add-to-list 'company-frontends 'company-echo-metadata-frontend)

  ;; Other settings...
  (setq company-idle-delay 0.2
        company-minimum-prefix-length 2
        company-tooltip-limit 20
        company-tooltip-align-annotations t
        company-selection-wrap-around t
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case t
        company-show-numbers t
        company-require-match 'never)

  ;; C-[number] is easier to push than M-[number]
  (dotimes (i 9)
    (define-key company-active-map (read-kbd-macro (format "C-%d" i))
      'company-complete-number))

  ;; Abort company with Escape
  (define-key company-active-map (kbd "ESC") 'company-abort)
  (add-hook 'after-init-hook 'global-company-mode))
#+end_src

#+begin_src emacs-lisp
(use-package company-quickhelp
  :after company
  :config (company-quickhelp-mode))
#+end_src

** Spell checking

I no longer automatically enable =flyspell= in any modes; it has a
pretty significant performance penalty.  =flyspell-buffer= works well
though.

I disable the default Emacs bindings because they conflict with too
much of my stuff.  Evil puts in the vim binds (=[s= & =]s= to move,
=z== to correct), which work fine for my needs.

#+begin_src emacs-lisp
(use-package flyspell
  :commands (flyspell-buffer
             flyspell-goto-next-error
             flyspell-auto-correct-word)
  :bind (:map flyspell-mode-map
              ; conflicts with yas-expand
              ("C-;" . nil)
              ; conflicts with emmet-expand
              ("C-," . nil)))
#+end_src

** Snippets

[[https://github.com/joaotavora/yasnippet][YASnippet]] provides "snippets" like provided by Textmate, then by every
other fancy paid text editor thereafter.

#+begin_src emacs-lisp
(use-package yasnippet
  :bind ("C-;" . yas-expand)
  :config
  (yas-global-mode 1)
  (define-key yas-keymap (kbd "C-j") 'yas-next-field-or-maybe-expand)
  (define-key yas-keymap (kbd "C-;") 'yas-next-field-or-maybe-expand)
  (define-key yas-keymap (kbd "C-k") 'yas-prev-field)
  (dolist (keymap (list yas-minor-mode-map yas-keymap))
    (define-key keymap (kbd "TAB") nil)
    (define-key keymap [(tab)] nil)))
#+end_src

Install a default set of snippets.

#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :after yasnippet
  :config
  (yasnippet-snippets-initialize))
#+end_src

** =recentf=: Recent files

I use this from =consult-recent-files=

#+begin_src emacs-lisp
(use-package recentf
  :init
  (recentf-mode t)
  :custom
  (recentf-max-saved-items 50))
#+end_src

** =ibuffer=

Generally I just use the incremental narrowing menus, but [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][regular 'ol
=ibuffer= is surprisingly powerful]] with a bit of cleanup.

[[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] groups everything in =ibuffer= together by version control
repositories.  This goes a *long* way towards some sanity.

#+begin_src emacs-lisp
(use-package ibuffer-vc
  :hook (ibuffer-hook . ibuffer-vc-set-filter-groups-by-vc-root)
  :after ibuffer)
#+end_src

=ibuffer-vc= creates a lot of filter groups; they tend to hang around, so hide
them when they aren't being used:

#+begin_src emacs-lisp
(setq ibuffer-show-empty-filter-groups nil)
#+end_src

Don't prompt every time you delete a buffer:

#+begin_src emacs-lisp
(setq ibuffer-expert t)
#+end_src

** Window management

=winner= allows window splits to be undone and redone at will.  It comes with
Emacs.

#+begin_src emacs-lisp
(use-package winner
  :commands (winner-undo winner-redo)
  :config (winner-mode 1))
#+end_src

=buffer-move= allows buffers to be moved between window splits.

#+begin_src emacs-lisp
(use-package buffer-move
  :commands (buf-move-left buf-move-down buf-move-up buf-move-right))
#+end_src

** Search packages

I used to use Paradox, but I doubt it interops well with straight.el.

I'm pulling in [[https://emacsmirror.net/manual/epkg/][epkg]] instead.  You can't install from it, but I
wouldn't think it'd be too hard to inspect the package listed on
current line and pass that to =straight-use-package=... but that's for
later.

#+begin_src emacs-lisp
(use-package epkg
  :commands (epkg-list-packages))
#+end_src

** Diffing

[[https://oremacs.com/2015/01/17/setting-up-ediff/][These settings]] beat the hell out of the defaults:

#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)

(defun jws/ediff-hook ()
  "Taken from https://oremacs.com/2015/01/17/setting-up-ediff/"
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" 'ediff-next-difference)
  (define-key ediff-mode-map "k" 'ediff-previous-difference))
(add-hook 'ediff-mode-hook 'jws/ediff-hook)

(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+end_src

** Version control

*** Everything that isn't =git=

Everything that isn't =git= is handled by =vc=.  If you work for
BigCorp or for a real conservative project and you find they won't
move off =svn= (or, [deity] forbid, =cvs=), =vc= is actually not half
bad: see [[https://www.youtube.com/watch?v=SQ3Beqn2CEc][this video]], or [[https://old.reddit.com/r/emacs/comments/9b5z79/the_built_in_version_control_is_pretty_cool/][this Reddit discussion]].

#+begin_src emacs-lisp
(use-package vc
  :defer t
  :straight nil
  :general
  (jws/primary-leader
    "v" '(:ignore t :wk "VC")
    "vv" '(magit-status :wk "Magit")
    "vc" '(:ignore t :wk "Generic")
    "vca" '(vc-annotate :wk "Annotate")
    "vcc" '(jws/vc-dir-root :wk "RootDir") ; vc-dir-root does not exist on my emacs 27.1
    "vcC" '(vc-dir :wk "PickDir")
    "vcd" '(vc-diff :wk "FileDiff")
    "vcD" '(vc-root-diff :wk "RepoDiff")
    "vch" '(vc-region-history :wk "RegionHistory")
    "vcl" '(vc-print-log :wk "Log")
    "vcm" '(vc-merge :wk "Merge")
    "vcn" '(vc-next-action :wk "Next")
    "vcr" '(vc-revert :wk "Revert")
    "vcp" '(vc-push :wk "Push")
    "vcu" '(vc-update :wk "Update"))
  :commands (vc-dir vc-root-dir))
#+end_src

Here I define a handy command that doesn't exist yet in Emacs 27.1:

#+begin_src emacs-lisp
(defun jws/vc-dir-root ()
  "Open vc-dir in vc-root-dir."
  (interactive)
  (vc-dir (vc-root-dir)))
#+end_src

*** Git with Magit

[[https://magit.vc/][Magit]], the rare Emacs package that can just about pull in money,
that's how good it is.

I launch Magit with =SPC v v=.

#+begin_src emacs-lisp
(use-package magit
  :defer t
  :commands (magit-status
             magit-branch-checkout
             magit-blame
             magit-get-current-branch
             magit-init
             magit-log-all-branches)
  :config
  ;; Otherwise it'll bother you about something or another on first run
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+end_src

I use [[https://nvie.com/posts/a-successful-git-branching-model/][git-flow]] ([[https://danielkummer.github.io/git-flow-cheatsheet/][cheatsheet]]) with some of my larger projects.  It does
add some mental overhead, but I like the ability to separate
development flow from a stable "live" version.

#+begin_src emacs-lisp
(use-package magit-gitflow
  :after magit
  :config
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
  (define-key magit-mode-map "%" 'magit-gitflow-popup))
#+end_src

This gives us the nice gutter icons when lines are added or changed
that you can find in newer editors.

#+begin_src emacs-lisp
(use-package git-gutter :config (global-git-gutter-mode t))
#+end_src

I may start using =git svn=, in which case =magit-svn= should be
helpful.  To enable it in a repository, go to its directory and run

#+begin_src bash :tangle no
git config --add magit.extension svn
#+end_src

I already had to hack on it some to get it to work in GCC Emacs, and
there's still some bitrot.  Will play with it more should I need it.

#+begin_src emacs-lisp
(use-package magit-svn
  :straight (magit-svn
             :host github :repo "jws85/magit-svn")
  :after magit
  :config
  (define-key magit-mode-map "#" 'magit-svn))
#+end_src

** Project management

[[https://github.com/bbatsov/projectile][Projectile]] is the current best-in-class for this purpose.

#+begin_src emacs-lisp
(use-package projectile
  :general
  (jws/primary-leader
    "p" '(:keymap projectile-command-map :package projectile :wk "Project"))
  :custom
  (projectile-completion-system 'default)
  ;; svn ls -R is *unusably* slow, find is like a rocketship in comparison
  (projectile-svn-command "find . \\( -path '*/.svn*' -o -path '*/.git*' \\) -prune -o -type f -print0")
  :config
  (projectile-mode 1))
#+end_src

** Code synchronization

I like Unison for this; it keeps code synced between local and remote
boxes, and does it fairly promptly.

Read [[https://www.cis.upenn.edu/~bcpierce/unison/][Unison]] profile configurations:

#+begin_src emacs-lisp
(use-package unison-mode
  :mode ("\\.prf\\'"))
#+end_src

A command to run Unison inside of a buffer:

#+begin_src emacs-lisp
(use-package unison
  :commands (unison))
#+end_src

And, finally, a command to look through the Unison =~/.unison=
directory and find profiles to be run by the above command:

#+begin_src emacs-lisp
(defun jws/unison-run ()
  "Runs unison with the given profile."
  (interactive)
  (let ((unison-args
         (list
          (completing-read
           "Profile: "
           (mapcar #'f-base (f-glob "*.prf" "~/.unison"))))))
    (unison)))
#+end_src

I tend to run Unison daemonized; to kill the daemon, it is a
simple matter of killing the =*unison*= buffer.

** Alerts

See [[https://github.com/jwiegley/alert][alert]] for more.

#+BEGIN_SRC emacs-lisp :results none
(use-package alert
  :config
  ;; bug: will not send alerts unless this is set...
  (setq alert-default-style 'notifications))
#+end_src

* Editing

Supposedly some people use Emacs to edit files.  The horror!

** Basic editing tools

This will automatically timestamp any file with =Time-stamp: <>=
towards its top on save.  This is less necessary in the era of Git
everywhere, but hey.

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'time-stamp)
#+end_src

If the file you're editing has a shebang (=#!=) at its top, Emacs
can make it executable, which we will do after saving.

#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src

I want Emacs to remember where I was in a file when I had it open
last; =save-place-mode= accomplishes that.

#+begin_src emacs-lisp
(use-package saveplace
  :init (save-place-mode))
#+end_src

[[http://emacs-fu.blogspot.com/2009/01/balancing-your-parentheses.html][show-paren-mode]] (included with emacs) highlights the matching paren.
It's good for all languages, but I would be reduced to a gibbering
mess without this enabled for Lisp.

Note that [[*Lisps][with Lisps]] I use the below
=jws/set-paren-style-to-expression= to highlight the whole
s-expression.

#+begin_src emacs-lisp
(show-paren-mode)

(defun jws/set-paren-style-to-expresion ()
  "Unconditionally turn on show-paren-mode in expression mode."
  (setq-local show-paren-style 'expression)
  (show-paren-mode t))

;; Make the face gaudy for match mode, but not as gaudy for expression mode
(set-face-attribute 'show-paren-match nil
                    :weight 'bold :underline t :foreground nil :background "#aa0000")
(set-face-attribute 'show-paren-match-expression nil
                    :underline nil :background "#330022")
#+end_src

=focus= is a neat package that only highlights the specific chunk of
code that your cursor is on.

#+begin_src emacs-lisp
(use-package focus :commands (focus-mode))
#+end_src

=prism=, on the other hand, colorizes *everything* according to the
code's nesting depth -- which can be handy for Lisp/JS callback hell!

#+begin_src emacs-lisp
(use-package prism
  :commands (prism-mode prism-whitespace-mode)
  :config
  (prism-set-colors :num 16
    :desaturations (cl-loop for i from 0 below 16
                            collect (* i 2.5))
    :lightens (cl-loop for i from 0 below 16
                       collect (* i 2.5))
    :colors (list "dodgerblue" "medium sea green" "sandy brown")

    :comments-fn
    (lambda (color)
      (prism-blend color
                   (face-attribute 'font-lock-comment-face :foreground) 0.25))

    :strings-fn
    (lambda (color)
      (prism-blend color "white" 0.5))))
#+end_src

=expand-region= selects increasingly large areas of text when used
repeatedly (with Evil normal mode =+=).

#+begin_src emacs-lisp
(use-package expand-region
  :commands er/expand-region)
#+end_src

=avy= jumps to any character on screen (Evil normal =g c=) and any
line on screen (Evil normal =g l=).

#+begin_src emacs-lisp
(use-package avy
  :commands (avy-goto-char avy-goto-line))
#+end_src

=ace-window= jumps between windows.

#+begin_src emacs-lisp
(use-package ace-window
  :commands ace-window)
#+end_src

[[https://github.com/akicho8/string-inflection][string-inflection]] allows the user to change how a string is
capitalized and punctuated according to language specifications.  For
instance, the below "Java style" function changes =testString= to
=TEST_STRING= to =TestString= and back to =testString= again.

[[https://github.com/ninrod/evil-string-inflection][evil-string-inflection]] wraps the above and makes it available as the
Evil command =g~=

#+begin_src emacs-lisp
(use-package string-inflection
   :commands (string-inflection-all-cycle
              string-inflection-java-style-cycle
              string-inflection-python-style-cycle))

(use-package evil-string-inflection
  :after (string-inflection evil))
#+end_src

** Whitespace settings

a/k/a tabs vs. spaces, which has now found its way into a major HBO
comedy show as mentioned in the introduction.

And lo and behold, emacs' tabs/spaces settings are wacky and I'm not
sure I properly understand them tbh.

I personally prefer spaces and 4-spaces-per-indent, but don't
particularly care so long as there is some consistency.  However, I've
been finding that with =indent-tabs-mode= turned off by default, that
my indentation in a few modes (namely =web-mode=, =css-mode=, probably
others) gets all hashed up.  Every eight spaces of indentation is
replaced with a hard tab, and the rest of the spaces are left.  This
is like literally the worst of all worlds, so I smash this setting
into place.

(Don't worry, I turn this back on for Makefiles.)

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

=untabify= on backspace is an amazingly bassackwards way of handling
things.  I hack on other peoples' projects that use tabs, and one
thing I know for sure is that folks who use tabs do NOT want their
tabs turned into spaces.  Just incomprehensibly broken.  Whomever
decided this has worms in their brains.  Why.

#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+end_src

** Character encoding

I want to force UTF-8 everywhere, even on Windows; ultimately most of
my code is compiled/run on Unixes and Windows settings actively get in
the way of that.  Some resources on the matter:

 - [[https://stackoverflow.com/a/2903256]]
 - [[https://rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows]]

The latter notes that you must be careful on Windows as to which
settings you enable.

#+begin_src emacs-lisp
(setq utf-translate-cjk-mode nil ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
      locale-coding-system 'utf-8)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system
  (if (eq system-type 'windows-nt) 'utf-16-le 'utf-8))
(prefer-coding-system 'utf-8)
#+end_src

** Regular expressions

You can use =re-builder= to try regular expressions against your
current text and see what it'd match (including capturing groups).
Unfortunately it only supports the regexes that Emacs supports -- no
PCRE.

Out of the box, it'll use the unwieldy "escaped in a string" syntax
(=read=); set it to =string= instead ([[https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder][see here]]) to not barf slashes
everywhere.  Use the =C-c C-w= syntax to copy said expression to a
format that can be used as an elisp string instead.

#+begin_src emacs-lisp
(use-package re-builder
  :config
  (setq reb-re-syntax 'string))
#+end_src

** Comma-separated-value files

=csv-align-mode= is worth it by itself.

#+begin_src emacs-lisp
(use-package csv-mode
  :mode ("\\.[Cc][Ss][Vv]\\'"))
#+end_src

* Writing
** org-mode

[[https://orgmode.org/][org-mode]] is one of the commonly cited "Emacs killer apps" (next to
Magit, which we configure elsewhere).

If you aren't familiar with =org-mode=, it's a markup format not
unlike Markdown.

But the format contains syntax (and =org-mode= itself contains
functionality) for a *very* full-featured, customizable personal
information manager; a full-on [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] system (which is
used to create this very Emacs config); and more.

Like a lot of folks, I tend to use it as an always-available personal
wiki of sorts; this is easy to accomplish with
Dropbox/Nextcloud/Syncthing/etc.

First, let's define some paths into my =org-mode= files.

#+begin_src emacs-lisp
(setq org-directory (expand-file-name "~/Org/"))

(defvar jws/org-agenda-dir (concat org-directory "agenda/")
  "The directory where `org-mode' agenda files live.")

(defvar jws/org-todo-file (expand-file-name "todo.org" jws/org-agenda-dir)
  "TODO file")

(defvar jws/org-reminder-file (expand-file-name "reminders.org" jws/org-agenda-dir)
  "File containing routine reminders")

(defvar jws/org-journal-dir (expand-file-name "~/Journal/")
  "The directory where `org-mode' journal files live.")

(defvar jws/org-notes-dir (concat org-directory "notes/")
  "The directory where `deft' notes files live.")
#+end_src

Do some basic configuration of =org-mode=.

#+begin_src emacs-lisp
(defun jws/org-mode-disable-company ()
  "Disable company-mode in org-mode buffers"
  (company-mode -1))

(use-package org
  :commands (org-export-dispatch
             org-babel-tangle-file)
  :general
  (jws/primary-leader
    "l" '(org-store-link :wk "StoreLink"))
  :mode (("\\.org\\'" . org-mode))
  :hook ((org-mode-hook . jws/org-mode-disable-company))
  :init
  (setq org-modules nil)
  :custom
  (org-src-window-setup 'current-window)
  (org-src-fontify-natively t)
  (org-src-preserve-indentation t)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  (org-highlight-latex-and-related nil)
  ;; easily link to various sites
  (org-link-abbrev-alist '(("wikipedia"    . "https://en.wikipedia.org/wiki/%s")
                           ("wikivoyage"   . "https://en.wikivoyage.org/wiki/%s")
                           ("rationalwiki" . "https://rationalwiki.org/wiki/%s"))))
#+end_src

Set up a hydra which lets us navigate org-mode files and change
metadata easily:

#+begin_src emacs-lisp
(defhydra jws/hydra-org (:hint none)
  "
Org (_q_uit)

^Movement^                 ^Structure^         ^Metadata^ ^^    ^Selecting^     ^Other^
^--------^---------------  ^---------^-------  ^--------^-^^--  ^---------^---  ^-----^--------
_j_ next heading           _J_ move tree down  _d_eadline ^^    _v_ mark tree   _e_xport
_k_ prev heading           _K_ move tree up    p_r_iority ^^    _x_ cut tree    re_c_alc table
_n_ next heading on level  _N_ promote item    _s_cheduled ^^   _y_ paste tree  toggle _i_mages
_p_ prev heading on level  _P_ demote item     _t_odo status^^
_u_p a level               _w_ refile          t_a_gs ^^        ^Linking^
_g_oto heading             _C-n_ promote tree  _←_ _→_ cycle  ^-------^-----
_TAB_ open/close heading   _C-p_ demote tree   _↑_ _↓_ cycle    insert _l_ink
^^                         _$_ archive tree    ^^^^             _S_tore link
"
  ("q" nil :exit t)

  ("TAB" org-cycle)
  ("j" org-next-visible-heading)
  ("k" org-previous-visible-heading)
  ("n" org-forward-heading-same-level)
  ("p" org-backward-heading-same-level)
  ("g" consult-outline)
  ("u" outline-up-heading)

  ("J" org-move-subtree-down)
  ("K" org-move-subtree-up)
  ("N" org-do-promote)
  ("P" org-do-demote)
  ("w" org-refile)
  ("C-n" org-promote-subtree)
  ("C-p" org-demote-subtree)
  ("$" org-archive-subtree)

  ("v" org-mark-subtree)
  ("x" org-cut-subtree)
  ("y" org-paste-subtree)

  ("l" org-insert-link)
  ("S" org-store-link)

  ("d" org-deadline)
  ("r" org-priority)
  ("s" org-schedule)
  ("t" org-todo)
  ("a" org-set-tags-command)

  ("<left>" org-shiftleft)
  ("<down>" org-shiftdown)
  ("<up>" org-shiftup)
  ("<right>" org-shiftright)

  ("e" org-export-dispatch :exit t)
  ("c" (org-table-recalculate t))
  ("i" org-toggle-inline-images))
#+end_src

And load it whenever an org-mode file is opened:

#+begin_src emacs-lisp
(jws/secondary-leader
  :keymaps 'org-mode-map
  "o" '(jws/hydra-org/body :wk "Org"))
#+end_src

*** Capturing new notes

=org-capture= is a really convenient way of automating the entry of
new entries in org files.

Here are the capture templates I use for journaling and planning; note
that =org-roam= has its own separate templates that I use for making
notes and bookmarking websites.

#+begin_src emacs-lisp
(use-package org-capture
  :after org
  :straight nil
  :defer t
  :general
  (jws/primary-leader
    "q" '(org-capture :wk "Capture"))
  :config
  (setq org-capture-templates
        '(("j" "Journal" entry
           (file+olp+datetree
            (lambda () (expand-file-name
                        (concat (format-time-string "%Y") ".org")
                        jws/org-journal-dir)))
           "* %?\nEntered on %U\n%i"
           :empty-lines 1)

          ;; reminders: things that are scheduled or will 'happen'
          ("r" "Reminder")
          ("rc" "Career" entry
           (file+olp jws/org-reminder-file "Career")
           "* %?\n%U\n%i\n"
           :empty-lines 1)
          ("re" "Events" entry
           (file+olp jws/org-reminder-file "Events")
           "* %?\n%U\n%i\n"
           :empty-lines 1)
          ("rl" "Life" entry
           (file+olp jws/org-reminder-file "Life")
           "* %?\n%U\n%i\n"
           :empty-lines 1)
          ("ru" "Uncategorized" entry
           (file+olp jws/org-reminder-file "Inbox")
           "* %?\n%U\n%i\n"
           :empty-lines 1)

          ;; TODO: things that I have to do
          ("t" "TODO")
          ("tc" "Career" entry
           (file+olp jws/org-todo-file "Career")
           "* TODO %?\n%U\n%i\n"
           :empty-lines 1)
          ("th" "Hobby" entry
           (file+olp jws/org-todo-file "Hobby")
           "* TODO %?\n%U\n%i\n"
           :empty-lines 1)
          ("tl" "Life" entry
           (file+olp jws/org-todo-file "Life")
           "* TODO %?\n%U\n%i\n"
           :empty-lines 1)
          ("tu" "Uncategorized" entry
           (file+olp jws/org-todo-file "Inbox")
           "* TODO %?\n%U\n%i\n"
           :empty-lines 1))))
#+end_src

*** Capturing from external applications

At the moment, this is being used by org-roam, [[https://www.orgroam.com/manual.html#Roam-Protocol][like so]].  You can also
use [[https://github.com/sprig/org-capture-extension][this WebExtension]] ([[https://addons.mozilla.org/en-US/firefox/addon/org-capture/][Firefox]], [[https://chrome.google.com/webstore/detail/org-capture/kkkjlfejijcjgjllecmnejhogpbcigdc][Chrome]]) to accomplish this.

Either way, some pretty substantial "outside of Emacs" configuration
has to be done.  The below are settings for "GTK-based Linux
environments" like GNOME.  Other environments will probably need
various changes.

First off, create =~/.local/share/applications/org-protocol.desktop= containing:

#+begin_src conf :tangle no
[Desktop Entry]
Name=org-protocol
Exec=emacsclient %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

Secondly, run the below, which updates =~/.local/share/applications/mimeinfo.cache=:

#+begin_src shell :tangle no
update-desktop-database ~/.local/share/applications/
#+end_src

Then, in Emacs, you must have a running server.  The usual recommendation is as
below, but I prefer starting my Emacs server process other ways:

#+begin_src emacs-lisp :tangle no
(server-start)
#+end_src

Finally, kick off =org-protocol= itself:

#+begin_src emacs-lisp
(use-package org-protocol :straight nil)
#+end_src

and that should cover everything!  Now you can click the org-mode
unicorn icon in your browser, and it should pop up a Emacsclient frame
somewhere with an org-mode link in it.

*** Agenda

=org-agenda= is the PIM component; it relies on "keywords" in subject
headers to detect things to act upon.

I define the following keywords:

 - =TODO= (as applied to something without dependencies) is a unit of
   work that, as far as I know, can be done now.
 - =DOING= is something I'm actively working on
 - =TESTING= is something I've finished, but am testing
 - =DEPLOYING= is something that just needs to be "put in place"
   e.g. copy the changes up to a live server
 - =DONE= is something that is finished
 - =WAITING= relies on something else that is out of my control
 - =CANCELLED= is something that was aborted before finishing

#+begin_src emacs-lisp
;; Grabbed this logic from https://stackoverflow.com/questions/62228905/org-mode-agenda-reuse-code-in-block-agenda
(setq jws/skip-todo
      '(org-agenda-skip-function '(org-agenda-skip-entry-if
                                   'scheduled 'deadline 'timestamp
                                   'todo '("BACKBURNER"))))

(defun jws/org-save-all-org-buffers (&rest _ignore)
  "Apply `org-save-all-org-buffers` ignoring all arguments.

This function was taken directly from https://emacs.stackexchange.com/a/52897.
I am not the original poster of that question, so thank you 'Tobias' for your
great explanation and 'quantum285' for asking the question in the first place."
  (org-save-all-org-buffers))

(use-package org-agenda
  :straight nil
  :defer t
  :general
  (jws/primary-leader
    "a" '(org-agenda :wk "Agenda"))
  :after org
  :custom
  (org-log-done t)
  (org-agenda-span 'day)
  (org-agenda-default-appointment-duration 60)
  (org-agenda-files (list jws/org-todo-file jws/org-reminder-file))
  (org-use-fast-todo-selection t)
  (org-log-into-drawer t)
  (org-archive-location "finished.org::datetree/*")
  ;; iCalendar export settings
  (org-icalendar-timezone "America/New_York")
  (org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
  (org-icalendar-store-UID t)
  ;; TODO keywords
  (org-todo-keywords
   '((sequence "TODO(t)" "DOING(o!)" "TESTING(e!)" "DEPLOYING(y!)" "|" "DONE(d!)")
     (sequence "WAITING(w@)" "|")
     (sequence "|" "CANCELLED(c@)")))
  ;; Tags
  (org-tag-alist
   '(("@career" . ?c)
     ("@event" . ?e)
     ("@gtd" . ?g)
     ("@hobby" . ?h)
     ("@life" . ?l)
     ("@recurring" . ?r)
     ("@travel" . ?t)))
  ;; Custom commands
  (org-agenda-custom-commands
   `(("c" "Complete view"
      ((agenda "" ((org-agenda-overriding-header "Scheduled\n")))
       (todo "" ((org-agenda-overriding-header "\nUnscheduled") ,jws/skip-todo))))))
  :config
  ;; Agenda vim key bindings
  (evil-add-hjkl-bindings org-agenda-mode-map 'emacs
    (kbd "C") 'cfw:open-org-calendar
    (kbd "c") 'org-agenda-capture
    (kbd "d") 'org-agenda-goto-date
    (kbd "L") 'org-agenda-log-mode
    (kbd "a") 'jws/hydra-org-agenda/body)

  ;; Save after various edits in org-mode/org-agenda
  (advice-add 'org-deadline :after #'jws/org-save-all-org-buffers)
  (advice-add 'org-refile :after #'jws/org-save-all-org-buffers))
#+end_src

Define a hydra to do things inside =org-agenda= itself.  This is taken
[[https://github.com/abo-abo/hydra/wiki/Org-agenda][from here]] (which in turn came from [[https://www.spacemacs.org/][Spacemacs]]) and modified to my
preferences.

#+begin_src emacs-lisp
(defhydra jws/hydra-org-agenda (:pre (setq which-key-inhibit t)
                                     :post (setq which-key-inhibit nil)
                                     :hint none)
  "
Org agenda (_q_uit)

^Clock^      ^Visit entry^              ^Date^            ^Other^
^-----^----  ^-----------^------------  ^----^----------  ^-----^---------
_@i_ in      _SPC_ in other window      _s_ schedule      _r_ reload
_@o_ out     _TAB_ & go to location     _d_ set deadline  _._ go to today
_@q_ cancel  _RET_ & del other windows  _+_ do later      _g_ go to date
_@j_ jump    _o_   link                 _-_ do earlier    _c_apture
^^           ^^                         ^^                _C_alendar
^^           ^^                         ^^                ^^
^Filter^                 ^Headline^        ^Toggle mode^
^------^---------------  ^--------^------  ^-----------^----
_Ft_ by tag              _z_ add note      _f_ follow
_Fr_ refine by tag       _p_ set priority  _l_ log
_Fc_ by category         _t_ set status    _a_ archive trees
_Fh_ by top headline     _w_ refile        _A_ archive files
_Fx_ by regexp           _:_ set tags      _#_ clock report
_Fd_ delete all filters  _$_ archive       _D_ diaries
^^                       ^^                 ^^
"
  ;; Entry
  ("z" org-agenda-add-note)
  ("p" org-agenda-priority)
  ("t" org-agenda-todo)
  ("w" org-agenda-refile)
  ("$" org-agenda-archive-default)
  (":" org-agenda-set-tags)
  ;; Visit entry
  ("o"   link-hint-open-link :exit t)
  ("<tab>" org-agenda-goto :exit t)
  ("TAB" org-agenda-goto :exit t)
  ("SPC" org-agenda-show-and-scroll-up)
  ("RET" org-agenda-switch-to :exit t)
  ;; Date
  ("d" org-agenda-deadline)
  ("s" org-agenda-schedule)
  ("+" org-agenda-do-date-later)
  ("-" org-agenda-do-date-earlier)
  ;; Toggle mode
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("#" org-agenda-clockreport-mode)
  ("f" org-agenda-follow-mode)
  ("l" org-agenda-log-mode)
  ("D" org-agenda-toggle-diary)
  ;; Filter
  ("Fc" org-agenda-filter-by-category)
  ("Fx" org-agenda-filter-by-regexp)
  ("Ft" org-agenda-filter-by-tag)
  ("Fr" org-agenda-filter-by-tag-refine)
  ("Fh" org-agenda-filter-by-top-headline)
  ("Fd" org-agenda-filter-remove-all)
  ;; Clock
  ("@q" org-agenda-clock-cancel)
  ("@j" org-agenda-clock-goto :exit t)
  ("@i" org-agenda-clock-in :exit t)
  ("@o" org-agenda-clock-out)
  ;; Other
  ("q" nil :exit t)
  ("g" org-agenda-goto-date)
  ("." org-agenda-goto-today)
  ("r" org-agenda-redo)
  ("c" org-capture)
  ("C" cfw:open-org-calendar))
#+end_src

[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] groups agenda items together, which makes the agenda
a heckuva lot easier to read.

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-map nil
        org-super-agenda-groups
        '((:name "Today" :time-grid t :deadline today)
          (:name "Important" :priority "A")
          (:name "GTD" :tag "@gtd")
          (:name "Career" :tag "@career")
          (:name "Events" :tag "@life" :tag "@event")
          (:name "Hobby" :tag "@hobby")
          (:name "Travel" :tag "@travel")
          (:auto-category t))))
#+end_src

[[https://github.com/kiwanami/emacs-calfw][calfw]] gives a nice calendar view of org-agenda items.

#+begin_src emacs-lisp
(use-package calfw
  :commands (cfw:open-calendar-buffer))

(use-package calfw-org
  :commands (cfw:open-org-calendar))
#+end_src

*** Note taking

Using [[https://www.orgroam.com/][org-roam]] for a [[https://en.wikipedia.org/wiki/Zettelkasten][Zettelkasten]] (tl;dr: "glorified personal wiki").

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :general
  (jws/primary-leader
   "z" '(nil :wk "Zettel")
   "zb" '(jws/org-roam-search-bookmarks :wk "Bookmarks")
   "zg" '(org-roam-graph :wk "Graph")
   "zi" '(org-roam-find-index :wk "Index")
   "zl" '(org-roam-insert :wk "InsertLink")
   "zs" '(deft :wk "FindString")
   "zz" '(org-roam-find-file :wk "FindNote"))
  :commands (org-roam org-roam-find-file org-roam-db-query org-roam-protocol-open-ref)
  :config
  (require 'org-roam-protocol)
  (setq org-roam-directory jws/org-notes-dir
        ;; turn on company-mode for org-roam files, because of tag autocomplete
        org-roam-file-setup-hook (lambda () (company-mode +1))
        ;; capture template from inside Emacs
        org-roam-capture-templates
        '(("d" "default" plain #'org-roam-capture--get-point "\n%?\n\n"
           :file-name "%<%Y%m%d%H%M%S>-${slug}"
           :head "#+title: ${title}\n#+time_created: %U\n#+roam_tags: \n"
           :unnarrowed t))
        ;; capture template from web link outside Emacs
        org-roam-capture-ref-templates
        '(("r" "references" plain #'org-roam-capture--get-point "\n%?\n\n"
           :file-name "%<%Y%m%d%H%M%S>-${slug}"
           :head "#+title: ${title}\n#+time_created: %U\n#+roam_key: ${ref}\n#+roam_tags: links \n"
           :unnarrowed t))))
#+end_src

I lean on the capture templates *heavily* for bookmarking, see below.

I used to use [[https://github.com/jrblevin/deft][Deft]] as a quick-notes tool but found that my notes
became structureless.  However, =org-roam= lacks a fulltext search,
and Deft has it... so we're bringing it back on board.

#+begin_src emacs-lisp
(use-package deft
  :after org
  :defer t
  :commands deft
  :config
  (setq deft-directory jws/org-notes-dir
        deft-recursive t
        deft-extensions '("org")
        deft-default-extension "org"
        deft-new-file-format "%Y%m%d%H%M%S"))
#+end_src

*** Bookmarking

I use org-roam for keeping various bookmarks I find interesting.

The capture templates are called from various web browsers using the
following JavaScript (from [[https://www.orgroam.com/manual.html#Roam-Protocol][here]]); I use this to manage bookmarks
across browsers:

#+begin_src javascript :tangle no
javascript:location.href =
    'org-protocol://roam-ref?template=r&ref='
    + encodeURIComponent(location.href)
    + '&title='
    + encodeURIComponent(document.title)
    + '&body='
    + encodeURIComponent(window.getSelection())
#+end_src

The following searches the =org-roam= database for all bookmarks
(e.g. everything tagged =links=).  Its output is consumed by the
below functions.

#+begin_src emacs-lisp
(defun jws/org-roam-bookmarks ()
  "Get all bookmarks from org-roam"
  (org-roam-db-query
   [:select [titles:title refs:ref]
            :from titles
            :left :join tags :on (= titles:file tags:file)
            :left :join files :on (= titles:file files:file)
            :left :join refs :on (= files:file refs:file)
            :where (and (= refs:type "website")
                        (like tags:tags '"%\"links\"%"))]))
#+end_src

This function presents my =org-roam= bookmarks as a =completing-read=
interface, allowing me to search them anywhere inside Emacs.

#+begin_src emacs-lisp
(defun jws/org-roam-check-url (url)
  "Check to see if URL is https or http.

If you store a URL as #+roam_key, org-roam strips the protocol
information before storing it.  Which is a little frustrating if
you are (ab)using org-roam as a bookmark tool."
  (let ((https (concat "https:" url))
        (http (concat "http:" url)))
    (condition-case nil
        (if (url-http-file-exists-p https)
            https
          http)
      ((error) http))))

(defun jws/org-roam-search-bookmarks ()
  "Search bookmarks and open them in a web browser."
  (interactive)
  (let ((bookmarks (jws/org-roam-bookmarks)))
    (jws/browse-url-browser-select
     (jws/org-roam-check-url
      (cadr (assoc
             (completing-read "Bookmarks: " bookmarks nil t)
             bookmarks))))))
#+end_src

And this function inter-operates with [[https://github.com/jws85/Dotfiles/blob/main/roles/desktop/files/scripts/rofi-roam-bookmarks][this script I wrote]] which uses
[[https://github.com/davatorium/rofi][rofi]] as a search interface, thus allowing me to search my bookmarks
outside of Emacs entirely.

#+begin_src emacs-lisp
(defun jws/org-roam-bookmarks-rofi ()
  "Display bookmark data in format acceptable to Rofi"
  (let ((temp-file (make-temp-file "RoamBookmarks-")))
    (with-temp-file temp-file
      (dolist (bookmark (jws/org-roam-bookmarks))
        (insert (concat (car bookmark) " -- "
                        (cadr bookmark) "\n"))))
    temp-file))
#+end_src

I also want to bookmark web-related things I might read inside
Emacs; I can use the below function to do this in various modes:

#+begin_src emacs-lisp
(defun jws/org-roam-capture-ref (title url)
  "Capture an org-roam ref note with TITLE and URL."
  (org-roam-protocol-open-ref
   (list :template "r" :ref url :title title)))
#+end_src

*** Conversion

 - Enable Markdown conversion (the others are defaults)
 - Have HTML backend emit HTML5 instead of XHTML

#+begin_src emacs-lisp
(use-package ox
  :straight nil
  :defer t
  :after org
  :init (setq org-export-backends '(ascii html icalendar latex odt md))
  :config
  (setq org-html-doctype "html5"
        org-html-html5-fancy t))
#+end_src

=ox-hugo= provides batch conversion to [[https://gohugo.io][Hugo]]'s Markdown format.

#+begin_src emacs-lisp
(use-package ox-hugo
  :defer t
  :after ox)
#+end_src

=ox-wk= provides conversion to [[https://www.dokuwiki.org/dokuwiki][Dokuwiki]]; I often start documents for
work in Org and then copy it into our work wiki.

#+begin_src emacs-lisp
(use-package ox-wk
  :defer t
  :after ox
  :commands (ox-wk-export-as-wiki
             ox-wk-export-to-wiki)
  :config
  (setq ox-wk-org-verbatim 'monospace))
#+end_src

=htmlize= lets the HTML exporter colorize your source blocks.

#+begin_src emacs-lisp
(use-package htmlize :defer t)
#+end_src

*** Literate programming

#+begin_src emacs-lisp
(use-package ob
  :after org
  :straight nil
  :custom
  (org-babel-confirm-evaluate nil))
#+end_src

We want to avoid =org-babel-do-load-languages= because it eagerly
loads all modules associated with that language ([[https://blog.d46.us/advanced-emacs-startup/][see here]]) instead of
adding languages to that variable, expose the module's equivalent
=org-babel-execute= and =org-babel-expand-body= functions.

#+begin_src emacs-lisp
(use-package ob-shell
  :defer t
  :straight nil
  :commands (org-babel-execute:sh
             org-babel-expand-body:sh
             org-babel-execute:bash
             org-babel-expand-body:bash))

(use-package ob-ledger
  :defer t
  :straight nil
  :commands (org-babel-execute:ledger
             org-babel-expand-body:ledger))

(use-package ob-python
  :defer t
  :straight nil
  :commands (org-babel-execute:python))
#+end_src

** Markdown

Ideally I'd stay in org-mode, but I live in the real world.

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("\\.md\\'" "\\.markdown\\'" "\\.mdown\\'"))
#+end_src

** Ledger

#+begin_src emacs-lisp
(use-package ledger-mode
  :mode ("\\.ledger\\'"))
#+end_src

* Coding
** Coding tools
*** Xref

=xref= is emacs' built-in, basic functionality to jump to definitions
and refereneces.  For non-Lisp languages it relies on =ctags= and the
like.

#+begin_src emacs-lisp
(use-package xref
  :straight nil
  :bind (:map xref--xref-buffer-mode-map
              ("j" . xref-next-line)
              ("k" . xref-prev-line))
  :config
  ;; by default, xref-find-references prompts, even when you're on a usable symbol
  ;; turn that off...
  (setq xref-prompt-for-identifier nil)
  ;; put user in emacs mode for xref's buffer
  (add-to-list 'evil-emacs-state-modes 'xref--xref-buffer-mode))
#+end_src

Make a hydra to handle xref.

#+begin_src emacs-lisp
(defhydra jws/hydra-xref (:exit t :hint nil)
  "
Xref
-------------------
_d_ _D_ definition
_r_ _R_ references
_p_ ^ ^ pop stack"
  ("d" xref-find-definitions)
  ("D" xref-find-definitions)
  ("r" xref-find-references)
  ("R" xref-find-references)
  ("p" xref-pop-marker-stack))
#+end_src

In programming modes, set =, x= to run that hydra.  Note that
=lsp-mode= (when available, on =, l=) has much more functionality.

#+begin_src emacs-lisp
(jws/secondary-leader
  :keymaps 'prog-mode-map
  "x" '(jws/hydra-xref/body :wk "Xref")
  "c" '(compile :wk "Compile"))
#+end_src

*** Flymake

I had =flycheck= and =flymake= confused for a while.  =flymake= comes
with Emacs, and =flycheck= looks a little nicer.  =flymake= was
historically not great, but was significantly improved at some point.

I'm trying =flymake= for a bit in part of an effort to go a little
closer to basics.

=flymake= is automatically enabled whenever =lsp-mode= is turned on,
otherwise it has to be enabled in a given mode.

Set up =flymake= keybindings on =, e=.

#+begin_src emacs-lisp
(general-define-key
 :states 'normal
 "[ g" 'flymake-goto-prev-error
 "] g" 'flymake-goto-next-error)

(jws/secondary-leader
  "e" '(consult-flymake :wk "Errors"))
#+end_src

*** LSP support

[[https://en.wikipedia.org/wiki/Language_Server_Protocol][LSP]] is a protocol that allows text editors to communicate with servers
that can parse and introspect source code.  Microsoft created it for
VS Code; thankfully Microsoft made the protocol open this time (and
hopefully they stick to that in the future...)

To get Emacs to speak LSP, install [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]]:

#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :commands (lsp
             lsp-describe-session
             lsp-describe-thing-at-point
             lsp-execute-code-action
             lsp-find-declaration
             lsp-find-type-definition
             lsp-format-buffer
             lsp-rename
             lsp-restart-server
             lsp-signature-help
             lsp-workspace-restart
             lsp-workspace-folders-remove
             lsp-workspace-folders-add
             lsp-workspace-shutdown)
  :config
  ;; I haven't noticed problems at ~2500 files...
  (setq lsp-file-watch-threshold 2000))
#+end_src

[[https://github.com/emacs-lsp/lsp-ui][lsp-ui]] adds some fancy features on top of =lsp-mode=:

#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode
  :requires lsp-mode
  :hook (lsp-mode-hook . lsp-ui-mode)
  :commands (lsp-ui-peek-find-definitions
             lsp-ui-peek-find-references
             lsp-ui-peek-find-implementation
             lsp-ui-doc-glance
             lsp-ui-imenu)
  :config
  (setq lsp-ui-doc-enable t
        lsp-ui-doc-use-childframe t
        lsp-ui-doc-position 'at-point
        lsp-ui-doc-max-height 25
        lsp-ui-doc-max-width 60
        lsp-ui-doc-include-signature t
        lsp-ui-doc-delay 0.8
        lsp-ui-sideline-enable nil
        lsp-ui-peek-enable t
        lsp-ui-peek-list-width 60
        lsp-ui-peek-peek-height 25
        lsp-ui-sideline-enable nil))
#+end_src

A hydra to control LSP (taken from [[https://github.com/abo-abo/hydra/wiki/lsp-mode][the examples on the hydra wiki]]):

#+begin_src emacs-lisp
(defhydra jws/hydra-lsp (:exit t :hint nil)
  "
Buffer^^             Server^^                 Symbol
-----------------------------------------------------------------------------------------------------
_f_ format           _C-r_ restart            _d_ definition   _i_ implementation  _o_ documentation
_m_ imenu            _S_   shutdown           _D_ declaration  _t_ type            _R_ rename
_x_ execute action   _C-s_ describe session   _r_ references   _s_ signature       _p_ pop stack
^^                   _C-d_ remove folders
^^                   _C-v_ restart server"
  ("D" lsp-find-declaration)
  ("d" lsp-ui-peek-find-definitions)
  ("r" lsp-ui-peek-find-references)
  ("i" lsp-ui-peek-find-implementation)
  ("t" lsp-find-type-definition)
  ("s" lsp-signature-help)
  ("o" lsp-describe-thing-at-point)
  ("R" lsp-rename)
  ("p" xref-pop-marker-stack)

  ("f" lsp-format-buffer)
  ("m" lsp-ui-imenu)
  ("x" lsp-execute-code-action)

  ("C-s" lsp-describe-session)
  ("C-r" lsp-restart-workspace)
  ("C-d" lsp-workspace-folders-remove)
  ("C-v" lsp-restart-server)
  ("S" lsp-workspace-shutdown))
#+end_src

And bind it:

#+begin_src emacs-lisp
(add-hook 'lsp-mode-hook
          (lambda ()
            (jws/secondary-leader
              :keymaps 'local
              "l" '(jws/hydra-lsp/body :wk "LSP"))))
#+end_src

*** Browse Dash docsets with Zeal

I used [[https://github.com/dash-docs-el/counsel-dash][counsel-dash]] for awhile but

 - It felt like docs took forever to download/extract... not sure if it was
   issues with the docset server, or with Emacs not being particularly
   performant with big JSON blobs, or simply because I misconfigured it

 - I'm trying to move away from the counsel-* ecosystem

In lieu of that, I'm using [[http://zealdocs.org/][Zeal]] in conjunction with [[https://github.com/jinzhu/zeal-at-point][zeal-at-point]].  I'm
not a fan of having a separate program... would much rather a local web
server with the docsets hosted locally and the web server would literally
exist only as a search frontend.  But until that program exists...

#+begin_src emacs-lisp
(use-package zeal-at-point
  :ensure t
  :commands (zeal-at-point)
  :general ("C-/" #'zeal-at-point))
#+end_src

Bind =zeal-at-point= functionality:

#+begin_src emacs-lisp
(jws/secondary-leader
  :keymaps 'prog-mode-map
  "/" '(zeal-at-point :wk "Zeal"))
#+end_src

** Data markup & configuration files

But we're using Lisp -- data is code!

*** JSON

JSON will be handled by whatever JavaScript mode I pull in.

*** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

*** TOML

#+begin_src emacs-lisp
(use-package toml-mode
  :mode "\\.toml\\'")
#+end_src

*** XML

=nxml-mode= is built into Emacs; this is enough to work with XML
itself (including its various schema/transform dialects).

I like the (non-XML-based) [[https://en.wikipedia.org/wiki/RELAX_NG#Compact_syntax][RELAX NG compact syntax]]:

#+begin_src emacs-lisp
(use-package rnc-mode
  :mode "\\.rnc\\'")
#+end_src

** Configuration languages (including build scripts)

*** Vimscript

Yep, a little bit of heresy!

Enable it for =vimrc=, =gvimrc=, and =vifmrc=, as well as all =.vim= and =.vifm= files.

#+begin_src emacs-lisp
(use-package vimrc-mode
  :mode ("\\(g\\)?vi\\(f\\)?mrc\\'"
         ".vi\\(f\\)?m\\'"))
#+end_src

*** Makefiles

The below is super super super important, as one of the few exceptions
to my "I don't like tabs but so long as the code is consistent" stance
-- Makefiles require tabs, full stop.

#+begin_src emacs-lisp
(add-hook 'makefile-mode-hook (setq-local indent-tabs-mode t))
#+end_src

*** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile\\'")
#+end_src

** Lisps

I actually am a dabbler in Lisps, rather than actually doing anything
productive with them.  But since knowing some Lisp is necessary for
doing anything non-trivial with Emacs... here we are!

Let's group a bunch of Lisp mode hooks so we don't have to keep typing
them out below.

#+begin_src emacs-lisp
(defvar jws/lisp-mode-hooks
  '(emacs-lisp-mode-hook
    common-lisp-mode-hook
    scheme-mode-hook
    clojure-mode-hook
    lisp-interaction-mode-hook
    lisp-mode-hook
    racket-mode-hook))
#+end_src

Let's start by turning on [[*Flymake][flymake]].

#+begin_src emacs-lisp
(dolist (hook jws/lisp-mode-hooks)
  (add-hook hook #'flymake-mode))
#+end_src


[[*Basic editing tools][Leverage our existing show-paren-mode config]] to better highlight Lisp
s-expressions.  This turns =show-paren-mode= from just indicating the
matching paren, to actually highlighting the whole affected region.

#+begin_src emacs-lisp
(dolist (hook jws/lisp-mode-hooks)
  (add-hook hook #'jws/set-paren-style-to-expresion))
#+end_src

I had been using [[https://github.com/DogLooksGood/parinfer-mode][the Emacs implementation]] of [[http://shaunlebron.github.io/parinfer/index.html][Parinfer]] quite happily,
but I've noticed some bugginess with it.  So I might as well learn one
of these ersatz Lisp modes with their slurping and barfing and all.

#+begin_src emacs-lisp
(defun jws/lispy-fix-delete ()
  "For whatever reason delete doesn't work with lispy and evil, let's fix that."
  (interactive)
  (general-define-key :states 'insert :keymaps 'override
                      "<delete>" 'lispy-delete-backward
                      "C-d" 'lispy-delete))

(use-package lispy
  :init
  (dolist (hook jws/lisp-mode-hooks)
    (add-hook hook #'lispy-mode))
  :config
  (setq lispy-visit-method 'projectile
        lispy-close-quotes-at-end-p t)
  (lispy-set-key-theme '(lispy special c-digits evilcp))
  (add-hook 'lispy-mode-hook 'jws/lispy-fix-delete))

(use-package lispyville
  :init
  (dolist (hook jws/lisp-mode-hooks)
    (add-hook hook #'lispyville-mode))
  :config
  (lispyville-set-key-theme '(operators
                              c-w
                              (escape insert)
                              (additional-movement normal visual motion)))
  (setq lispyville-motions-put-into-special t))
#+end_src

[[https://github.com/nonsequitur/idle-highlight-mode/blob/master/idle-highlight-mode.el][idle-highlight-mode]] highlights everywhere a token is used.  Enabled for
Lisps only because =lsp-mode= includes this functionality.

#+begin_src emacs-lisp
(use-package idle-highlight-mode
  :init
  (dolist (hook jws/lisp-mode-hooks)
    (add-hook hook #'idle-highlight-mode)))
#+end_src


*** Emacs Lisp

[[https://github.com/Malabarba/Nameless][nameless]] hides the namespace part of elisp function/variable names.

#+begin_src emacs-lisp
(use-package nameless
  :hook (emacs-lisp-mode-hook . nameless-mode))
#+end_src

[[https://github.com/cask/cask][Cask]] is like [[https://getcomposer.org/][Composer]] or =npm= for Emacs Lisp.  I don't use Cask much,
but I have used it from time to time when developing plugins.

#+begin_src emacs-lisp
(use-package cask-mode
  :mode "Cask\\'")
#+end_src

*** Common Lisp

#+begin_src emacs-lisp
(use-package common-lisp-mode
  :straight nil
  :mode "\\.lisp\\'")
#+end_src

#+begin_src emacs-lisp
(use-package sly
  :after common-lisp-mode
  :commands (sly))
#+end_src

*** Clojure

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode "\\.clj\\'")

(use-package cider
  :after clojure-mode)
#+end_src

*** Racket

#+begin_src emacs-lisp
(use-package racket-mode
  :mode ("\\.rkt\\'"))
#+end_src

** Curly-brace/C-family

For curly-brace languages, I like underscores to be part of the Emacs
"word" editing object.

#+begin_src emacs-lisp
(defun jws/make-underscores-belong-to-words ()
  "Make underscore characters be counted as parts of Emacs 'word' objects."
  (modify-syntax-entry ?_ "w"))

(add-hook 'c-mode-common-hook 'jws/make-underscores-belong-to-words)
#+end_src

*** C and its immediate relatives

Let's enable =lsp-mode= for these folks.

For =c-mode= and =c++-mode= you'll want the =clangd= from =clang-tools-8=.

#+begin_src emacs-lisp
(defun jws/cpp-dash-docsets ()
  "Use C & C++ docsets"
  (setq-local zeal-at-point-docset '("c" "cpp")))

(use-package c-mode
  :straight nil
  :hook
  (c-mode-hook . lsp)
  :mode ("\\.\\(c\\|h\\)\\'"))

(use-package c++-mode
  :straight nil
  :hook
  (c++-mode-hook . lsp)
  (c++-mode-hook . jws/cpp-dash-docsets)
  :mode "\\.\\(c\\|h\\)pp\\'")
#+end_src

*** PHP

I am currently paid to write PHP, so most of the effort is going to go
here.  =php-mode= is useful for files with very little HTML/CSS/JS in
them; if your PHP is more like HTML template code, use =web-mode=
instead.

=lsp-mode= is great.  If you are on a recent-ish version of PHP,
you'll need [[https://www.npmjs.com/package/intelephense][Intelephense]], which requires NodeJS/NPM to install.
Intelephense is not "Free Software" but its free version works fine
for autocompletion and linting, and I used it this way for a few
months before buying it for $10.  I can confirm that at least
Intelephense's class renaming (one of the paid features) works with
=lsp-mode=.

#+begin_src emacs-lisp
(defun jws/php-dash-docsets ()
  "Use PHP & Laravel docsets"
  (setq-local zeal-at-point-docset '("php" "laravel")))

(use-package php-mode
  :commands php-mode
  :mode "\\.php\\'"
  :hook
  (php-mode-hook . jws/make-underscores-belong-to-words)
  (php-mode-hook . jws/php-dash-docsets)
  (php-mode-hook . lsp)
  :custom
  (c-basic-offset 4))
#+end_src

=auto-mode-alist= loads by precedence; the first match wins.  As such,
I want to specifically load =.blade.php= with =web-mode= and defer the
rest to =php-mode=.  =add-to-list= appends, so we want to put the Blade
(and other templates) matcher *after* the default PHP matcher.  Whew!

(Unfortunately, [[https://emacs.stackexchange.com/questions/12500/exclude-a-string-in-emacs-regexp/12502][elisp regex cannot do lookahead]], so you [[https://stackoverflow.com/a/1732454][can't simply
match]] "not =blade=".)

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.blade\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\.php\\'" . web-mode))
#+end_src

*** Go

I like Go a lot, despite some irritating parts.  It is like a stricter
but much faster curly-brace Python.

Again here we enable =lsp-mode=, this time using [[https://github.com/golang/tools/tree/master/gopls][gopls]].  I grabbed
some of this code from [[https://lupan.pl/dotemacs/][this Emacs config]].

#+begin_src emacs-lisp
;; Set up before-save hooks to format buffer and add/delete imports.
;; Make sure you don't have other gofmt/goimports hooks enabled.
(defun jws/lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))

;; Set compilation command
(defun jws/go-compilation-command ()
  (set (make-local-variable 'compile-command)
       "go build -v && go test -v && go vet"))

(use-package go-mode
  :mode "\\.go\\'"
  :hook
  (go-mode-hook . lsp-deferred)
  (go-mode-hook . jws/lsp-go-install-save-hooks)
  (go-mode-hook . jws/go-compilation-command))

(use-package go-guru
  :after go-mode)
#+end_src

*** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :mode "\\.rs\\'"
  :config
  (add-hook 'rust-mode-hook 'lsp))
#+end_src

*** JavaScript

I installed the (currently unmaintained, but works at the moment)
[[https://github.com/theia-ide/typescript-language-server][typescript-language-server]].  There are [[https://emacs-lsp.github.io/lsp-mode/page/lsp-typescript/][installation instructions here]].
Previously I had [[https://github.com/ananthakumaran/tide][tide]] but I hadn't completely configured it and I'm
already going in on the LSP model for things going forwards so...

#+begin_src emacs-lisp
(defun jws/js-dash-docsets ()
  "Use various JavaScript library docsets"
  (setq-local zeal-at-point-docset '("javascript" "jquery")))

(defun jws/js-lsp-setup ()
  "Ignore npm vendor folder to make lsp faster"
  (push "[/\\\\]node_modules[/\\\\]" lsp-file-watch-ignored)
  (lsp))

(use-package js2-mode
  :mode "\\.js\\'"
  :config
  (add-hook 'js2-mode-hook 'jws/js-dash-docsets)
  (add-hook 'js2-mode-hook 'jws/js-lsp-setup))
#+end_src

I don't use CoffeeScript but I've had to read code using it.  I'm
including it here because it is part of the "JavaScript ecosystem" as
far as I'm concerned.

#+begin_src emacs-lisp
(use-package coffee-mode
  :mode "\\.coffee\\'"
  :config
  (setq coffee-tab-width 4))
#+end_src

*** Kotlin

#+begin_src emacs-lisp
(use-package kotlin-mode
  :mode ("\\.kt\\'" "\\.kts\\'"))
#+end_src

** Other
*** Lua

#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'")
#+end_src

*** Python

#+begin_src emacs-lisp
(use-package python-mode
  :mode "\\.py\\'")
#+end_src

I'm using [[https://github.com/microsoft/pyright][Pyright]] for Python completions:

#+begin_src emacs-lisp
(defun jws/lsp-pyright ()
  "Load lsp-mode and pyright when python-mode is loaded"
  (require 'lsp-pyright)
  (lsp-deferred))

(use-package lsp-pyright
  :defer t
  :hook (python-mode-hook . jws/lsp-pyright))
#+end_src

To install Pyright, install NodeJS v12.x or greater (on Ubuntu 20.04,
you'll need the [[https://github.com/nodesource/distributions/blob/master/README.md][Node repositories]] added) and then:

#+begin_src shell :tangle no
sudo npm install -g pyright
#+end_src

*** Forth

#+begin_src emacs-lisp
(use-package forth-mode
  :mode "\\.\\(4th\\|f\\(s\\|th\\)?\\)\\'")
#+end_src

*** Fish (shell)

#+begin_src emacs-lisp
(use-package fish-mode
  :mode ("\\.fish\\'"))
#+end_src

** Web
*** Emmet

[[https://github.com/smihica/emmet-mode][emmet-mode]] implements the [[https://emmet.io/][Emmet]] syntax, which can speed up creation of
heavily-nested HTML.

For instance, =ol#nav>li.color*3>a= is an Emmet shortcut for:

#+begin_src html :tangle no
<ol id="nav">
  <li class="color"><a href=""></a></li>
  <li class="color"><a href=""></a></li>
  <li class="color"><a href=""></a></li>
</ol>
#+end_src

You would expand the former into the latter with =C-j=.

#+begin_src emacs-lisp
(use-package emmet-mode
  :bind (("C-." . emmet-expand-line))
  :hook (sgml-mode-hook php-mode-hook web-mode-hook css-mode-hook)
  :config
  (unbind-key "C-j" emmet-mode-keymap))
#+end_src

*** web-mode

This mode handles mixed-mode code (e.g. PHP with HTML/CSS/JS mixed
in), as well as template languages (Blade, Mustache, Jinja2...).

#+begin_src emacs-lisp
(use-package web-mode
  :commands web-mode
  :mode ("\\.html?\\'"
         "\\.phtml\\'"
         "\\.[agj]sp\\'"
         "\\.as[cp]x\\'"
         "\\.erb\\'"
         "\\.vue\\'"
         "\\.mustache\\'"
         "\\.djhtml\\'")
  :init (require 'web-mode)
  :config
  ;; Automatically close HTML quotes like other text editors, e.g.
  ;; when <tt> is typed, automatically insert </tt> and put point
  ;; between the two tags.  Also automatically insert quote marks
  ;; for a tag attribute.
  (setq web-mode-auto-close-style 2
        web-mode-enable-auto-pairing t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t)

  ;; I consider web-mode a programming mode.
  (add-hook 'web-mode-hook (lambda () (run-hooks 'prog-mode-hook))))
#+end_src

Enable =company= in =web-mode=.

#+begin_src emacs-lisp
(use-package company-web
  :after (company web-mode))
#+end_src

Open web-mode files in a web browser:

#+begin_src emacs-lisp
(defun jws/open-this-file-in-browser ()
  "Open this file in a web browser."
  (interactive)
  (if (buffer-file-name)
      (jws/browse-url-browser-select
       (concat "file://" (buffer-file-name)))))
#+end_src

Increasingly, in this era of LSP everywhere, I find myself wanting to
live in the native language mode.  But I have to maintain a depressing
amount of legacy mixed-mode PHP code.  I define the below function to
hop in and out of =web-mode=.

#+begin_src emacs-lisp
(defun jws/toggle-web-mode ()
  (interactive)
  (if (eq major-mode 'web-mode)
      (set-auto-mode)
    (web-mode)))
#+end_src

Easy bindings to our above functions:

#+begin_src emacs-lisp
(jws/secondary-leader
  :keymaps 'prog-mode-map
  "w" '(jws/toggle-web-mode :wk "ToggleWeb")
  "n" '(jws/open-this-file-in-browser :wk "OpenInBrowser"))
#+end_src

*** CSS/Sass

I've tried to use Sass from time to time, and still like the idea of
it.

#+begin_src emacs-lisp
(use-package scss-mode
  :mode "\\.scss\\'")
#+end_src

Appropriately colorize color names in CSS (and Sass/SCSS) files.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook (css-mode-hook scss-mode-hook))
#+end_src

*** REST Client

There is a handy [[https://github.com/pashky/restclient.el][REST client for emacs]] that uses its own DSL.

#+begin_src emacs-lisp
(use-package restclient
  :mode "\\.restclient$"
  :config
  (require 'restclient))
#+end_src

This package integrates =restclient= with =org-babel=.

#+begin_src emacs-lisp
(use-package ob-restclient
  :defer t
  :commands (org-babel-execute:restclient))
#+end_src

And this package integrates =company= with =restclient=.

#+begin_src emacs-lisp
(use-package company-restclient
  :after (restclient company)
  :hook (restclient-mode-hook . company-mode)
  :config
  (add-hook 'restclient-mode-hook
            (lambda ()
              (make-local-variable 'company-backends)
              (add-to-list 'company-backends 'company-restclient))))
#+end_src

** Qt-specific

I'm using Qt Creator for C++/QML at the moment, but I'd love it if I
could move it all into Emacs.  At the moment, I often launch Emacs
from Qt Creator in order to get Magit and easy macro editing.

QML is Qt's "new" UI description language, written in what looks like
curly-brace "HTML" combined with inline JavaScript.

#+begin_src emacs-lisp
(use-package qml-mode
  :mode "\\.qml\\'")
#+end_src

Qt's resource files (=.qrc=) are XML.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.qrc$" . nxml-mode))
#+end_src

* Utilities
** Seeing which libraries are running

The below is a small library I wrote to diagnose serious slowness
in these config files.  If I want to see what I've dragged in,
I can run =jws/features-report= to get a report of what all is
running, and trim this configuration accordingly.

Emacs calls these libraries 'features' and keeps them in the
=features= global variable as individual symbols which can be
queried e.g. by =locate-library=.

#+begin_src emacs-lisp
(defun jws/features-report ()
  "Generate report of running Emacs features/libraries."
  (interactive)
  (message "Please wait a moment if you have a large .emacs...")
  (let ((buffer (generate-new-buffer "*Features*")))
    (with-current-buffer buffer
      (insert (jws/features-report-header))
      (insert (jws/features-report-body))
      (goto-char (point-min))
      (view-mode 1)
      (display-buffer buffer '(display-buffer-pop-up-frame . nil)))))

(defun jws/features-report-header ()
  (format "FEATURES REPORT\n%s\nThere are %d features loaded:\n\n"
	  "============================================================"
	  (length features)))

(defun jws/features-report-body ()
  (setq output "")
  (dolist (f features output)
    (setq output
	  (concat output
		  (format " - %s: %s\n"
			  (symbol-name f)
			  (locate-library (symbol-name f))))))
  output)
#+end_src

** File management

=dired= is the built-in Emacs file manager.

#+begin_src emacs-lisp
(use-package dired
  :straight nil
  :defer t
  :general
  (jws/primary-leader
    "d" '(dired :wk "Dired")))
#+end_src

=dired= barfs a bunch of directory buffers every time you change a
directory.  Ticks me off.  I do this to try to control the madness.
Due to =evil-collection= I had to specially map =^=.

#+begin_src emacs-lisp
(use-package dired-single
  :after dired
  :defer t
  :bind (:map dired-mode-map
         ("^" . dired-single-up-directory)
         ("<return>" . dired-single-buffer)))
#+end_src

=dired-x= is a set of extensions to =dired=; I use =dired-omit-mode=
to hide and toggle the view of "hidden files"

#+begin_src emacs-lisp
(use-package dired-x
  :straight nil
  :after dired
  :defer t
  :commands dired-jump
  :hook ((dired-mode-hook . dired-omit-mode))
  :bind (:map dired-mode-map
         ("C-c h" . dired-omit-mode))
  :config
  (setq dired-omit-files "^\\...+$"))
#+end_src

Add =all-the-icons= icons:

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :after (dired all-the-icons)
  :defer t
  :hook (dired-mode-hook . all-the-icons-dired-mode))
#+end_src

=dired-rainbow= colorizes files; I've set it up here to colorize
executables.

#+begin_src emacs-lisp
(use-package dired-rainbow
  :after dired
  :defer t
  :config
  (dired-rainbow-define-chmod executable-unix "Green" "-[rw-]+x.*"))
#+end_src

And some other packages that I forgot the exact intent of.

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :defer t
  :bind (:map dired-mode-map
         ("C-c s a" . dired-subtree-insert)
         ("C-c s d" . dired-subtree-remove)))

(use-package dired-collapse
  :after dired
  :defer t
  :bind (:map dired-mode-map
         ("C-c c" . dired-collapse-mode)))
#+end_src

Finally, a function to open the home directory in Dired.

#+begin_src emacs-lisp
(defun jws/dired-home ()
  "Open user's home directory in Dired"
  (interactive)
  (dired "~"))

(defun jws/dired-root ()
  "Open / in Dired"
  (interactive)
  (dired "/"))
#+end_src

** Image display

Emacs is horribly unoptimized for this, but if we are viewing files,
we'll necessarily bump into multimedia files from time to time.

#+begin_src emacs-lisp
(defun jws/file-extension-regex (extension-list)
  "Create regex to match EXTENSION-LIST."
  (concat "\\." (regexp-opt extension-list) "\\'"))

(defun jws/image-type-regex ()
  "Regex matching image types supported by Emacs."
  (jws/file-extension-regex
   (map 'list #'symbol-name
        (--filter #'image-type-available-p image-types))))

(use-package image
  :straight nil
  ;; FIXME: I want to dynamically populate this with jws/image-type-regex
  :mode ("\\.\\(?:gif\\|jpeg\\|p\\(?:bm\\|ng\\)\\|svg\\|tiff\\|x\\(?:[bp]m\\)\\)\\'" . image-mode))
#+end_src

#+begin_src emacs-lisp
(use-package image+
  :after image
  :config
  (eval-after-load 'image '(require 'image+)))
#+end_src

** Calculator

Emacs Calc looks like a toy RPN calculator at first glance, until you
hit the manual and the "ugly" truth hits -- there's almost too much
functionality to really easily learn!

#+begin_src emacs-lisp
(use-package calc
  :straight nil
  :general
  (jws/primary-leader
    "c" '(calc-dispatch :wk "Calc"))
  :config
  ;; Logical/data size units
  (setq math-additional-units
        '((bit nil "Bit")
          (byte "8 * bit" "Byte")
          (bps "bit / s" "Bytes per second")
          ;; binary logical units
          (Kibyte "1024 * byte" "Kibibytes")
          (Mibyte "1024 * Kibyte" "Mebibytes")
          (Gibyte "1024 * Mibyte" "Gibibytes")
          (Tibyte "1024 * Gibyte" "Tebibytes"))
        math-units-table nil))
#+end_src

Playing around with currency conversion in Calc:

#+begin_src emacs-lisp
(use-package currency-convert
  :straight (currency-convert
             :host github :repo "jws85/emacs-currency-convert"
             :branch "emacs-calc-interop")
  :config
  (add-hook 'calc-start-hook 'currency-convert-calc-load))
#+end_src

** PDF viewer

Natively render PDFs in Emacs, using an external daemon to render the
PDFs into image files and send them to Emacs.

If you haven't yet, you *must* run =pdf-tools-install= prior to
opening a PDF with this viewer.  =pdf-tools= can build automatically
on install, but it requires human intervention (installing
=libpoppler= via package manager) and thus interferes with server
startup...

#+begin_src emacs-lisp
(use-package pdf-tools
  :straight (pdf-tools :flavor melpa :build nil)
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :commands (pdf-tools-install)
  :config
  (setq pdf-annot-activate-created-annotations t))
#+end_src

** ePub reader

#+begin_src emacs-lisp
(use-package nov
  :mode (".\\epub\\'" . nov-mode)
  :config
  (setq nov-text-width 72))
#+end_src

** Music player

[[https://github.com/pft/mingus][Unsurprisingly, Emacs can be an MPD frontend as well...]]  (Obviously,
you need to set up =mpd= first.)

#+begin_src emacs-lisp
(use-package mpc
  :commands (mpc-toggle-play
             mpc-next
             mpc-prev))

(use-package mingus
  :bind (:map mingus-*-map
         ("j" . 'next-line)
         ("k" . 'previous-line)
         ("/" . 'search-forward)
         ("?" . 'search-backward)
         :map mingus-playlist-map
         ("/" . 'search-forward)
         ("?" . 'search-backward))
  :commands (mingus
             mingus-search
             mingus-load-playlist
             mingus-save-playlist
             mingus-vol-up
             mingus-vol-down)
  :config
  (add-to-list 'evil-emacs-state-modes 'mingus-playlist-mode)
  (add-to-list 'evil-emacs-state-modes 'mingus-browse-mode))
#+end_src

Make a hydra to control =mpd= via mingus (idea stolen from [[https://writequit.org/eos/eos-music.html][here]]).

#+begin_src emacs-lisp
(defun jws/currently-playing ()
  "Get what is currently playing in mpd"
  (car (s-split "\n" (shell-command-to-string "mpc"))))

(defhydra jws/hydra-mpd nil
  "
MPD: %s(jws/currently-playing)
"
  ("SPC" mpc-toggle-play "Play/Pause")
  ("/" mingus-search "Search" :exit t)
  ("m" mingus "Mingus" :exit t)
  ("p" mpc-prev "Previous")
  ("l" mingus-load-playlist "Load playlist")
  ("s" mingus-save-playlist "Save playlist")
  ("n" mpc-next "Next")
  ("+" (dotimes (i 5) (mingus-vol-up)) "Louder")
  ("-" (dotimes (i 5) (mingus-vol-down)) "Quieter")
  ("q" nil "Quit"))

(jws/primary-leader
  "m" '(jws/hydra-mpd/body :wk "Music"))
#+end_src

** Timer

[[https://github.com/dxknight/chronos][chronos]] is a handy package for most timing-related purposes (e.g.
"pomodoro" timers and the like)

#+begin_src emacs-lisp
(use-package chronos
  :general
  (jws/primary-leader
    "@" '(chronos-add-timer :wk "Timer"))
  :config
  (add-to-list 'evil-emacs-state-modes 'chronos-mode)
  (evil-add-hjkl-bindings chronos-mode-map 'emacs
    (kbd "L") 'chronos-lap-selected-line)
  (setq chronos-expiry-functions '(chronos-desktop-notifications-notify)))
#+end_src

** Web browser

*** =eww=

=eww= is built into emacs.  =eww= is a tool of last resort, since
probably 90% of the web now expects robust JavaScript/CSS support that
emacs simply can't easily provide.

#+begin_src emacs-lisp
(use-package eww
  :straight nil
  :commands (eww eww-browse-url)
  :general
  (:keymaps 'eww-mode-map :states '(override normal)
            "b" 'jws/eww-capture-in-org-roam
            "f" 'ace-link-eww
            "y" 'eww-copy-page-url
            "J" 'evil-scroll-page-down
            "K" 'evil-scroll-page-up
            "SPC" nil))
#+end_src

The below captures a =ref= org-roam entry from an eww page, similarly
to doing the same thing via =org-protocol://= from an external web
browser.

#+begin_src emacs-lisp
(defun jws/eww-capture-in-org-roam ()
  "Capture an org-roam ref note with current eww page."
  (interactive)
  (let ((eww-title (plist-get eww-data :title))
        (eww-url (plist-get eww-data :url)))
    (jws/org-roam-capture-ref eww-title eww-url)))
#+end_src

Define a home page ([[https://duckduckgo.com][DuckDuckGo]]), and a function to load it.

#+begin_src emacs-lisp
(defvar jws/eww-home-page "https://duckduckgo.com/html/?kd=1")

(defun jws/eww-home ()
  (interactive)
  (eww jws/eww-home-page))

(jws/primary-leader
  "N" '(jws/eww-home :wk "Net"))
#+end_src

*** Other web browsers

I've tried using =eww= as the Emacs default, but even opening =eww= and
*then* going to some other browser is problematic.  Easier for me to
just offer choices.

Here's a list of browsers I use.  I set =browse-url-generic-program= to
[[https://qutebrowser.org/][Qutebrowser]].  The =eww-browse-url= and =browse-url-*= represent function
names provided by Emacs.

#+begin_src emacs-lisp
(setq browse-url-generic-program "qutebrowser")

(setq jws/browser-list
      '(("eww" eww-browse-url)
        ("firefox" browse-url-firefox)
        ("qutebrowser" browse-url-generic)))
#+end_src

Here is a function I use that offers up that list as a minibuffer
select.

#+begin_src emacs-lisp
(defun jws/browse-url-browser-select (url &optional new-window)
  "Select a browser and load URL in it"
  (interactive (browse-url-interactive-arg "URL: "))
  (let ((browse-fun (cadr (assoc
                           (completing-read "Select a browser: " jws/browser-list nil t)
                           jws/browser-list))))
    (funcall browse-fun url)))
#+end_src

Finally, tell Emacs to use the above function as the default browser
function whenever a web link is clicked, etc.

#+begin_src emacs-lisp
(setq browse-url-browser-function 'jws/browse-url-browser-select)
#+end_src

*** IRC

I actually kinda like this for IRC purposes.  I'm currently on
Quassel, so I'll probably need to set up a bouncer somewhere and use
that to connect.

I grabbed the settings from [[https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/][this Reddit post]].

#+begin_src emacs-lisp
(use-package erc
  :defer t
  :custom
  (erc-autojoin-timing 'ident)
  (erc-fill-function 'erc-fill-static)
  (erc-fill-static-center 22)
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
  (erc-lurker-threshold-time 43200)
  (erc-prompt-for-nickserv-password nil)
  (erc-server-reconnect-attempts 5)
  (erc-server-reconnect-timeout 3)
  (erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                             "324" "329" "332" "333" "353" "477"))
  :config
  (erc-services-mode 1)
  (erc-update-modules))
#+end_src

*** =ace-link= to click links with keyboard

[[https://github.com/abo-abo/ace-link][ace-link]] allows the user to select links with their keyboard.  It will
use =browse-url-browser-function= as above.

#+begin_src emacs-lisp
(use-package ace-link
  :after avy
  :general
  (jws/primary-leader
    "n" '(ace-link :wk "GotoLink"))
  :commands (ace-link-eww))
#+end_src

** Gopher/[[https://gemini.circumlunar.space/docs/faq.html][Gemini]] browser

Hey, why not.

#+begin_src emacs-lisp
(use-package elpher
  :commands (elpher))
#+end_src

** =elfeed=: RSS reader

[[https://github.com/skeeto/elfeed][elfeed]] is a pretty nice RSS reader.

#+begin_src emacs-lisp
(use-package elfeed
  :general
  (:keymaps 'elfeed-show-mode-map :states '(override normal)
            "b" 'jws/elfeed-show-capture-in-org-roam
            "y" 'elfeed-show-yank
            "SPC" nil)
  (:keymaps 'elfeed-search-mode-map :states '(override normal)
            "SPC" nil))
#+end_src

Similarly to =jws/eww-show-capture-in-org-roam=, this grabs the
content and makes an org-roam note:

#+begin_src emacs-lisp
(defun jws/elfeed-show-capture-in-org-roam ()
  "Capture displayed feed item into org-roam note"
  (interactive)
  (let ((elfeed-title (elfeed-entry-title elfeed-show-entry))
        (elfeed-url (elfeed-entry-link elfeed-show-entry)))
    (jws/org-roam-capture-ref elfeed-title elfeed-url)))
#+end_src

I know about [[https://github.com/remyhonig/elfeed-org][elfeed-org]] but I was running into issues with it,
planning on re-evaluating it later.

[[https://github.com/Manoj321/elfeed-dashboard][elfeed-dashboard]] provides a convenient interface to =elfeed=, so you
don't have to keep changing the filter settings to see different tags.
The way it handles configuration (using an org file at
=elfeed-dashboard-file=) is very interesting as well.

#+begin_src emacs-lisp
(use-package elfeed-dashboard
  :after elfeed
  :general
  (jws/primary-leader
    "r" '(elfeed-dashboard :wk "RSS"))
  :config
  (add-to-list 'evil-emacs-state-modes 'elfeed-dashboard-mode)
  ;; update feed counts on elfeed-quit
  (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links))
#+end_src

I keep various elfeed settings defined elsewhere and loaded in
=~/.emacs.d/site-init.el= with something like below:

#+begin_src emacs-lisp :tangle no
(setq elfeed-db-directory "~/Sync/.elfeed"
      elfeed-dashboard-file "~/Sync/Emacs/elfeed-dashboard.org"
      elfeed-feeds
      '(("http://php.net/releases/feed.php" programming php webdev)))
#+end_src

** Terminal

=eshell= is Emacs' built-in terminal.  It is *not* a Bash variant, but
is instead configured entirely with Emacs Lisp and renders solely to
an Emacs buffer (rather than a VT TTY emulator).  The result is that
at first it looks like a toy; when in fact you have the full power of
Emacs from =eshell= if you should want it.  The disadvantage is that
sometimes muscle memory from old-school term/shells gets in one's way.

#+begin_src emacs-lisp
(use-package eshell
  :straight nil
  :general
  (jws/primary-leader
    "!" '(eshell :wk "Term"))
  :hook (eshell-banner-load-hook . jws/eshell-banner)
  :hook (eshell-mode-hook . jws/eshell-keybindings)
  :config
  (setq eshell-scroll-to-bottom-on-input 'all
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        eshell-save-history-on-exit t
        eshell-prefer-lisp-functions nil
        eshell-destroy-buffer-when-process-dies t)

  ;; Open eshell in a split
  (add-to-list 'display-buffer-alist '(("\\`\\*e?shell" display-buffer-pop-up-window)))

  ;; Instead of ranger, why not use dired?
  ;; Instead of tig, why not use magit?
  ;; Still, in the off case these are used, use ansi-term
  (setq eshell-visual-commands
        '("htop" "iotop" "iftop" "less" "lynx" "minicom" "more" "pine" "ranger" "screen" "top" "tig" "vi"))

  ;; Set eshell prompt + regex
  (setq eshell-prompt-function #'jws/eshell-prompt
        eshell-prompt-regexp "[#>] ")

  (add-hook 'restclient-mode-hook
            (lambda ()
              (make-local-variable 'company-backends)
              (add-to-list 'company-backends 'company-pcomplete))))
#+end_src

Set keybindings:

#+begin_src emacs-lisp
(defun jws/eshell-keybindings ()
  "Keybindings for eshell"
  (general-define-key
   :keymaps 'eshell-mode-map
   :states '(override normal insert)
   "C-j" 'eshell-next-input
   "C-k" 'eshell-previous-input))
#+end_src

The eshell prompt itself, which displays the current Git branch, the
time the prompt was generated, etc:

#+begin_src emacs-lisp
(defun jws/eshell-prompt ()
  (concat
   "\n"
   (propertize (concat "\xf07c " (eshell/pwd))
               'face `(:foreground "#6c9ef8" :weight bold))
   " "
   (propertize (concat "\xf017 " (format-time-string "%H:%M" (current-time)))
               'face `(:foreground "#5699af" :weight bold))
   " "
   (if (magit-get-current-branch)
       (propertize (concat "\xf020 " (magit-get-current-branch))
                   'face `(:foreground "#bbfc20" :weight bold)))
   "\n"
   (propertize (if (= (user-uid) 0) "#" ">") 'face `(:foreground "#d02b61" :weight bold))
   (propertize " " 'face `(:foreground "white" :weight bold))))
#+end_src

If you haven't figured out yet, I like pointlessly goofy displays;
this will display every time I open the prompt:

#+begin_src emacs-lisp
(use-package lolcat :commands (lolcat lolcat-this-buffer))
(use-package figlet :commands (figlet))

(defun jws/eshell-banner ()
  "Display an 'informative' banner on eshell startup"
  ;; First off, don't do any of this junk over TRAMP!!!!
  (if (not (file-remote-p default-directory))
      (with-temp-buffer
        ;; equivalent to `hostname | figlet | lolcat` in shell
        (if (executable-find "figlet")
            (progn
              (setq-local figlet-default-font "slant")
              (figlet (system-name))
              (lolcat-this-buffer)
              (insert "running EmacsOS v.")
              (insert emacs-version)
              (insert "\n\n")))

        ;; print uptime
        (insert
         (concat (string-trim-left (shell-command-to-string "uptime"))
                 "\n"))

        ;; print fortune if command installed
        (if (executable-find "fortune")
            (insert (shell-command-to-string "fortune -s")))

        ;; dump to string and set banner to that
        (setq eshell-banner-message (buffer-string)))))
#+end_src

Use pcomplete and =company= to complete eshell input ([[http://xenodium.com/eshell-pcomplete-company-completion/][here]]):

#+begin_src emacs-lisp
(defun company-pcomplete--overlap-tail (a b)
  (let ((prefix a)
        (remaining nil))
    (while (and (not remaining) (> (length prefix) 0))
      (when (s-starts-with? prefix b)
        (setq remaining (substring b (length prefix))))
      (setq prefix (substring prefix 1)))
    remaining))

(defun company-pcomplete--candidates (prefix)
  "Get candidates for PREFIX company completion using `pcomplete'."
  ;; When prefix is: "~/Down" and completion is "Downloads\n", need
  ;; to find common string and join into "~/Downloads/".
  (-map (lambda (item)
          (if (s-starts-with? prefix item)
              item
            (concat prefix (company-pcomplete--overlap-tail prefix item))))
        (all-completions prefix (pcomplete-completions))))

(defun company-pcomplete (command &optional arg &rest ignored)
  "Complete using pcomplete. See `company''s COMMAND ARG and IGNORED for details."
  (interactive (list 'interactive))
  (case command
    (interactive (company-begin-backend 'company-pcomplete))
    (prefix (company-grab-symbol))
    (candidates
     (company-pcomplete--candidates arg))))
#+end_src

Any function or alias with a name beginning with =eshell/= becomes a
command inside =eshell= itself.  The result being that I can do
=open ~/.emacs.d/config.org= from inside =eshell= and it'll open up
that file in a new buffer.

#+begin_src emacs-lisp
(defalias 'eshell/open 'find-file)
(defalias 'eshell/emacs 'find-file)
(defalias 'eshell/edit 'find-file)
(defalias 'eshell/magit 'magit-status)
(defalias 'eshell/dired 'dired-jump)

(defun eshell/x ()
  (interactive)
  (eshell/exit)
  (delete-window))

;; Command history using completing-read
;; https://www.reddit.com/r/emacs/comments/lvw44q/weekly_tipstricketc_thread/gpeb8n3/
(defun eshell/h ()
  (interactive)
  (insert
   (completing-read "History: " (delete-dups (ring-elements eshell-history-ring)))))
#+end_src

There is also =ansi-term=, which attempts to be a VT terminal emulator.
I find it even more janky than =eshell=, and only use it as a fallback
for =ncurses= commands like =htop= as above.

** Dummy text

Insert [[https://en.wikipedia.org/wiki/Lorem_ipsum]["lorem ipsum" dummy text]]:

#+begin_src emacs-lisp
(use-package lorem-ipsum
  :commands (lorem-ipsum-insert-paragraphs))
#+end_src

* Master menu

I defer the master menu definitions to the end just to make sure
everything else has been done.

** Emacs menu
#+begin_src emacs-lisp
(defun jws/open-emacs-config ()
  "Open my Emacs config file."
  (interactive)
  (find-file jws/config-file))

(defun jws/open-emacs-site-config ()
  "Open my Emacs site config file."
  (interactive)
  (find-file jws/site-file))

(defun jws/server-shutdown (yn)
  "Prompt before killing the Emacs dæmon."
  (interactive "cKill the Emacs dæmon (y/n)? ")
  (if (eq yn ?y)
      (progn
        (save-some-buffers)
        (kill-emacs))))

(defun jws/untangle-emacs-config ()
  "Untangle config.org."
  (interactive)
  (org-babel-tangle-file jws/config-file))

(defun jws/reload-emacs-config ()
  "Reload the entire Emacs configuration.

If a prefix argument is provided, untangle config.org before reloading
the Emacs configuration."
  (interactive)
  (if current-prefix-arg
      (jws/untangle-emacs-config))
  (load-file (concat user-emacs-directory "early-init.el"))
  (load-file (concat user-emacs-directory "init.el")))
#+end_src

** Text editing menu

This menu allows fine-tuning of various text editing settings.

#+begin_src emacs-lisp
;; Defining functions for the hydra
(defun jws/toggle-tabs-spaces ()
  (interactive)
  (if (equal indent-tabs-mode t)
      (setq indent-tabs-mode nil)
    (setq indent-tabs-mode t)))

(defun jws/set-tab-stop (inc)
  (setq c-basic-offset inc)
  (setq tab-width inc))

(defun jws/get-indent-char ()
  (interactive)
  (if (equal indent-tabs-mode t) "tabs" "spaces"))

;; Defining a hydra to change text editing settings...
(defhydra jws/hydra-text-editing (:exit nil :columns 4)
  "
INDENTATION | Char: %s(jws/get-indent-char) | Size: %`tab-width | Electric: %`electric-indent-mode
"
  ("2" (jws/set-tab-stop 2) "Set tab stop to 2")
  ("4" (jws/set-tab-stop 4) "Set tab stop to 4")
  ("8" (jws/set-tab-stop 8) "Set tab stop to 8")
  ("t" jws/toggle-tabs-spaces "Toggle tab/space indent")
  ("e" electric-indent-mode "Toggle electric indent")
  ("TAB" tabify "Tabify the selection")
  ("SPC" untabify "Spacify the selection")
  ("w" whitespace-mode "Display whitespace"))

(jws/primary-leader
  "t" '(jws/hydra-text-editing/body :wk "Text"))
#+end_src

** Buffer menu

A simple function to jump back to the =*scratch*= buffer, which I'll
sometimes use to prototype elisp and sometimes to slice and dice
clipboard text:

#+begin_src emacs-lisp
(defun jws/scratch-switch ()
  (interactive)
  (switch-to-buffer "*scratch*"))
#+end_src

** Window menu

This menu manages editor splits, which Emacs calls *windows* because
Emacs was written well before the Macintosh/Windows-era language we
use to talk about GUIs.

If you want to manage the actual GUI windows themselves, you actually
want to manage *frames* and should be looking at the "Frame menu."

#+begin_src emacs-lisp
(jws/defmultihydra ((jws/hydra-windows :columns 4 :color blue)
                    (jws/hydra-windows-sticky :columns 4))
  "Buffer splitting"
  ("<tab>" other-window "Prev")
  ("RET" ace-window "Jump to")
  ("<left>" winner-undo "Undo split")
  ("<right>" winner-redo "Redo split")

  ("h" evil-window-left "Left")
  ("j" evil-window-down "Down")
  ("k" evil-window-up "Up")
  ("l" evil-window-right "Right")

  ("H" buf-move-left "Move left")
  ("J" buf-move-down "Move down")
  ("K" buf-move-up "Move up")
  ("L" buf-move-right "Move right")

  ("C-h" shrink-window-horizontally "Shrink width")
  ("C-l" enlarge-window-horizontally "Enlarge width")
  ("C-k" shrink-window "Shrink height")
  ("C-j" enlarge-window "Enlarge height")

  ("-" split-window-below "Horiz split")
  ("\\" split-window-right "Vert split")
  ("|" split-window-right "Vert split")
  ("=" balance-windows "Balance splits")

  ("w" evil-window-next "Next window")
  ("C-w" evil-window-next "Next window")
  ("x" delete-window "Remove current")
  ("X" delete-other-windows "Remove others")

  ("s" jws/hydra-windows-sticky/body "Sticky"))

(jws/primary-leader
  "s" '(jws/hydra-windows/body :wk "Windows")
  "S" '(jws/hydra-windows-sticky/body :wk "MultiWindows"))
#+end_src

Finally, let's replace Evil's split menu with mine, because I know
my keybindings better...

#+begin_src emacs-lisp
(general-define-key :keymaps '(normal)
                    "C-w" 'jws/hydra-windows/body)
#+end_src

** Frame/"window" menu

If you want to manage Emacs GUI windows, you want to manage *frames*.

#+begin_src emacs-lisp
(defhydra jws/hydra-frames (:exit t :columns 4)
  ("n" make-frame "New window")
  ("N" jws/make-maximized-frame "New maximized window")
  ("x" delete-frame "Close window")

  ("d" jws/use-default-frame-alist "Reset defaults")
  ("c" jws/calculate-frame-size "Calculate row/cols")
  ("m" toggle-frame-maximized "Toggle maximize")
  ("f" toggle-frame-fullscreen "Toggle fullscreen"))

(jws/primary-leader
  "w" '(jws/hydra-frames/body :wk "Frames"))
#+end_src

** Graphics menu

#+begin_src emacs-lisp
(defhydra jws/hydra-graphics (:columns 4)
  "Graphics"
  ("f" focus-mode "Focus")
  ("p" prism-mode "Prism")
  ("P" prism-whitespace-mode "Prism whitespace")
  ("t" load-theme "Load theme")

  ("=" jws/text-scale-reset "Reset font size")
  ("r" jws/text-scale-reset "Reset font size")

  ("+" text-scale-increase "Larger font")
  ("l" text-scale-increase "Larger font")

  ("-" text-scale-decrease "Smaller font")
  ("s" text-scale-decrease "Smaller font")

  ("o" jws/reset-transparency "Completely opaque")
  ("i" jws/increase-transparency "More transparent")
  ("d" jws/decrease-transparency "Less transparent"))

(jws/primary-leader
  "g" '(jws/hydra-graphics/body :wk "Gfx"))
#+end_src

** Master menu
I continue to be amazed that Emacs doesn't have this...

#+begin_src emacs-lisp
(defun jws/switch-to-previous-buffer ()
  "Switches to the previous buffer."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer))))
#+end_src

* Site-specific code

As much as I'd like to have a one-size-fits-all config, I've found
that impossible.  The easiest example would be fonts; on some machines
I might not have access to my preferred fonts, on others I might want
a bigger font size or whatever.

Furthermore, I might need a very specific mode, or set up mappings
to certain file extensions.

If I need to run specific (unpackaged) libraries, I keep them under
=site-lisp/= in this directory:

#+begin_src emacs-lisp
(if (file-exists-p jws/emacs-site-library-dir)
    (let ((default-directory jws/emacs-site-library-dir))
      (add-to-list 'load-path default-directory)
      (normal-top-level-add-subdirs-to-load-path)))
#+end_src

If a =site-init.el= doesn't already exist, write some minimal stuff
(a theme that doesn't make my eyes bleed, a default font, and set the
frame alist) to that location.

#+begin_src emacs-lisp
(unless (file-exists-p jws/site-file)
  (write-region (pp `(load-theme 'doom-dracula t)) nil jws/site-file t)
  (write-region (pp `(setq jws/default-font ,jws/default-font)) nil jws/site-file t)
  (write-region (pp `(jws/set-my-default-frame-alist)) nil jws/site-file t))
#+end_src

My site-specific init file is kept in the same directory as this
file, at =site-init.el=.  I may look into making an org file out of
this as well.

#+begin_src emacs-lisp
(load jws/site-file t)
#+end_src

And we load the =Customize= stuff here as well.

#+begin_src emacs-lisp
(load jws/custom-file t)
#+end_src

* Cleanup
** Setting the garbage collector threshold

Set the =gc-cons-threshold= (set in =early-init.el=) back to a less
drastic value.

Garbage-collected programming languages maintain a "trashcan" of
discarded data, and at some point the trash "has to be taken out."
=gc-cons-threshold= determines how big that trashcan is.  The bigger
the trashcan is, the less often you have to take the trash out.  But
taking the trash out is not a free action, and the larger the can is,
the harder actually taking it out is.

So a low =gc-cons-threshold= will cause lots of very small delays;
with enough large packages, it can feel like persistent lag.  A high
one will remove said small delays in favor of less frequent but longer
delays.

A lot of maintainers of heavier packages, like =lsp-mode=, feel that
the default of =800000= (800KB) is insufficient.  The emacs devs
themselves are unenthusiastic about setting it too large.  I'm
following [[https://www.reddit.com/r/emacs/comments/brc05y/is_lspmode_too_slow_to_use_for_anyone_else/eofulix/][this suggestion from one of the Emacs maintainers]] to try to
bump it up by a factor of 2 until it is responsive.

#+begin_src emacs-lisp
(setq gc-cons-threshold 6400000)
#+end_src
